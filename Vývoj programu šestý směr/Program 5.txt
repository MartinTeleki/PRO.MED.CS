*&---------------------------------------------------------------------*
*& Report ZPP_API_MATRIX_MAINT
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zpp_api_matrix_maint_tmp.


* ğŸ“Œ TABLE:     ZPP_API_MATRIX
* ğŸ“Œ Structure: ZPP_API_MATRIX_STR

* TOM: Select option z ZPP_API_MATRIX
TABLES: zpp_api_matrix.

DATA  gs_variant   TYPE          disvariant.

SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-011.
  SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE TEXT-012.
    SELECT-OPTIONS: s_sap_id FOR zpp_api_matrix-sap_id,
                    s_werks  FOR zpp_api_matrix-werks,
                    s_api_id FOR zpp_api_matrix-api_id,
                    s_charg  FOR zpp_api_matrix-charg,
                    s_datuv  FOR zpp_api_matrix-datuv,
                    s_datub  FOR zpp_api_matrix-datub.
  SELECTION-SCREEN END OF BLOCK b2.

  SELECTION-SCREEN BEGIN OF BLOCK b3 WITH FRAME TITLE TEXT-010.
    PARAMETERS: r_all   RADIOBUTTON GROUP rb1,
                r_val   RADIOBUTTON GROUP rb1,
                r_inval RADIOBUTTON GROUP rb1.
  SELECTION-SCREEN END OF BLOCK b3.
SELECTION-SCREEN END OF BLOCK b1.

* ğŸ“Œ  layout selection
SELECTION-SCREEN BEGIN OF BLOCK b05 WITH FRAME TITLE TEXT-013.
  PARAMETERS: p_varnt LIKE disvariant-variant.
SELECTION-SCREEN END OF BLOCK b05.


TYPES: BEGIN OF ty_zpp_api_matrix_str.
         INCLUDE    TYPE zpp_api_matrix_str.  " VloÅ¾Ã­ vÅ¡echna pole z tÃ©to struktury
TYPES:  END OF    ty_zpp_api_matrix_str.

CLASS lcl_app DEFINITION.
  PUBLIC SECTION.
* ğŸ“Œ  PÅ™idat konstanty a veÅ™ejnÃ¡ data

    METHODS:
      run,         " ğŸš€

      read,        " ğŸ•¶ï¸
      add_row,     " ğŸš€
*      insert_row,  " âœ…
*      update,      " âœ…
      save_row,
      delete,      " âŒ
      display,     " ğŸ’¡
      alv_create,  " âœ…
      alv_refresh, " ğŸ”„
      alv_edit,    " âœï¸
      " zobrazenÃ­ tabulky s logy
      read_popup,
      alv_create_popup,
      display_popup,

      handle_toolbar FOR EVENT toolbar OF cl_gui_alv_grid
        IMPORTING e_object e_interactive,

      handle_user_command FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm,

      handle_data_changed FOR EVENT data_changed OF cl_gui_alv_grid
        IMPORTING er_data_changed e_onf4 e_onf4_before e_onf4_after e_ucomm.

  PRIVATE SECTION.

    DATA:
      " ReferenÄnÃ­ promÄ›nnÃ© pro ALV Grid a Custom Container ğŸ–¥ï¸
      mo_grid             TYPE REF TO cl_gui_alv_grid,                " ALV Grid pro zobrazenÃ­ dat v tabulce ğŸ“Š
      mo_custom_container TYPE REF TO cl_gui_custom_container,        " Custom Container pro pÅ™izpÅ¯sobenÃ­ vzhledu ğŸ§°

      " Tabulky pro data z matrixu zpp_api_matrix ğŸ“
      mt_data             TYPE TABLE OF ty_zpp_api_matrix_str,        " HlavnÃ­ data pro zÃ¡znamy tabulky zpp_api_matrix_strğŸ“‹
      mt_data_final       TYPE TABLE OF ty_zpp_api_matrix_str,        " HlavnÃ­ data pro uloÅ¾enÃ­ do databÃ¡ze

      " Tabulka pro data z logÅ¯ zpp_api_matrix ğŸ“
      mt_data_popup       TYPE TABLE OF zpp_api_matrix_l.


ENDCLASS.                          "lcl_app DEFINITION

CLASS lcl_app IMPLEMENTATION.
  METHOD run.

    IF p_varnt IS NOT INITIAL.
      gs_variant-variant = p_varnt.
    ENDIF.

    read( ).
    display( ).
  ENDMETHOD.

  METHOD read.  " ğŸ•¶ï¸

    DATA:
      " Tabulka pro zÃ¡znamy z tabulky zpp_api_matrix ğŸ–¥ï¸
      lt_zpp_api_matrix TYPE TABLE OF zpp_api_matrix,

      " Tabulka pro data z ty_zpp_api_matrix_str ğŸ“„
      lt_data           TYPE TABLE OF ty_zpp_api_matrix_str,

      " Tabulky pro Makt ğŸ“‘
      lt_makt_matnr     TYPE TABLE OF makt.  " Tabulka materiÃ¡lovÃ½ch ÄÃ­sel ğŸ·ï¸

    " Data pro parametry ğŸ“Š

    CONSTANTS: lc_parts_value_1 VALUE 1 TYPE i,
               lc_parts_value_2 VALUE 2 TYPE i.

    IF r_all = 'X'. " Chci zobratit vÅ¡echny certifikÃ¡ty
      SELECT *
        FROM zpp_api_matrix
          WHERE sap_id IN @s_sap_id
          AND   werks  IN @s_werks
          AND   api_id IN @s_api_id
          AND   charg  IN @s_charg
          AND   datuv  IN @s_datuv
          AND   datub  IN @s_datub
          INTO CORRESPONDING FIELDS OF TABLE @lt_data.

    ELSEIF r_val = 'X'. " Chci zobrazit jen ty platnÃ©
      SELECT *
      FROM zpp_api_matrix
        WHERE sap_id IN @s_sap_id
        AND   werks  IN @s_werks
        AND   api_id IN @s_api_id
        AND   charg  IN @s_charg
        AND datub >= @sy-datum        " CertifikÃ¡t musÃ­ bÃ½t stÃ¡le platnÃ½
        AND datuv <= @sy-datum        " CertifikÃ¡t musÃ­ bÃ½t uÅ¾ aktivnÃ­
        AND datuv IS NOT INITIAL
        AND datub IS NOT INITIAL      " MusÃ­ mÃ­t vyplnÄ›nÃ© poÄÃ¡teÄnÃ­ datum a konenÄÃ© datum
        INTO CORRESPONDING FIELDS OF TABLE @lt_data.

    ELSE.
      SELECT *         "chci zobrazit jen ty neplatnÃ©
        FROM zpp_api_matrix
  WHERE sap_id IN @s_sap_id
  AND   werks  IN @s_werks
  AND   api_id IN @s_api_id
  AND   charg  IN @s_charg
  AND   datub < @sy-datum       " CertifikÃ¡t musÃ­ bÃ½t stÃ¡le platnÃ½
  OR    datuv > @sy-datum       " CertifikÃ¡t musÃ­ bÃ½t uÅ¾ aktivnÃ­
  OR   datuv IS INITIAL
  OR   datub IS INITIAL
 INTO CORRESPONDING FIELDS OF TABLE @lt_data.
    ENDIF.


*âœ… NaplnÄ›nÃ­ tabulky s krÃ¡tkÃ½m textem materiÃ¡lu
* TOM: stÃ¡le tu nenÃ­ IF lt_data[] IS NOT INITIAL.
    IF lt_data[] IS NOT INITIAL.
      SELECT * FROM makt
       INTO CORRESPONDING FIELDS OF TABLE lt_makt_matnr
       FOR ALL ENTRIES IN lt_data
       WHERE (  matnr = lt_data-sap_id
       OR    matnr = lt_data-api_id )
       AND  ( spras = sy-langu
       OR    spras = 'E' ).
    ENDIF.

* âœï¸ naÄÃ­st maktx pro HotovÃ½ vÃ½rovek
    LOOP AT lt_data REFERENCE INTO DATA(lr_data). "

      " NaÄtenÃ­ statusÅ¯ skrze pÅ™ehlednost
      IF r_all = 'X'.
        lr_data->verify = COND #( WHEN lr_data->datub >= sy-datum
                           AND lr_data->datuv <= sy-datum
                           AND lr_data->datub > lr_data->datuv
                           AND lr_data->datuv IS NOT INITIAL
                           THEN icon_green_light
                           ELSE icon_red_light ).
      ENDIF.
      DATA(lr_makt_matnr) = REF #( lt_makt_matnr[ matnr = lr_data->sap_id
                                                    spras = sy-langu ] OPTIONAL ).

      IF lr_makt_matnr IS INITIAL.
        lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->sap_id ] OPTIONAL ).
      ENDIF.

* TOM: pokd ta reference nebude ani po druhÃ©m ÄtenÃ­ naplnÄ›nÃ¡, tak ti to tady spadne
*      lr_data->maktx = COND #( WHEN lr_makt_matnr IS NOT INITIAL
*                               THEN lr_makt_matnr->maktx
*                               ELSE space ).

      IF lr_makt_matnr IS NOT INITIAL.
        lr_data->maktx = lr_makt_matnr->maktx.
      ELSE.
        lr_data->maktx = space.
      ENDIF.

*âœï¸ DoplnÄ›nÃ­ destinace pomocÃ­ splitu a readu
      IF lr_data->maktx IS NOT INITIAL.
        DATA(lv_string) = lr_data->maktx.
        SPLIT lv_string AT '(' INTO TABLE DATA(lt_parts).

        DATA(lv_substring) = lt_parts[ lc_parts_value_2 ].

        SPLIT lv_substring AT ')' INTO TABLE lt_parts.
        lv_substring = lt_parts[ lc_parts_value_1 ].

        lr_data->destination = lv_substring.
      ENDIF.


*âœï¸ naÄÃ­st maktx pro komponentu komponenty API_NAME
      lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->api_id
                                                    spras = sy-langu ] OPTIONAL ).

      IF lr_makt_matnr IS INITIAL.
        lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->api_id ] OPTIONAL ).
      ENDIF.

* TOM: pokd ta reference nebude ani po druhÃ©m ÄtenÃ­ naplnÄ›nÃ¡, tak ti to tady spadne
*      lr_data->api_name = COND #( WHEN lr_makt_matnr IS NOT INITIAL
*                                 THEN lr_makt_matnr->maktx
*                                 ELSE space ).

      IF lr_makt_matnr IS NOT INITIAL.
        lr_data->api_name = lr_makt_matnr->maktx.
      ELSE.
        lr_data->api_name = space.
      ENDIF.

      APPEND lr_data->* TO mt_data.

    ENDLOOP.
  ENDMETHOD.

  METHOD add_row.
    " Definice struktur pro data a prÃ¡zdnÃ© Å™Ã¡dky ğŸ“Š
    DATA:
      ls_data      TYPE ty_zpp_api_matrix_str. " Struktura pro data ğŸ“

    APPEND INITIAL LINE TO mt_data.

  ENDMETHOD.

  METHOD save_row.
    DATA  lt_makt_matnr     TYPE TABLE OF makt.  " Tabulka materiÃ¡lovÃ½ch ÄÃ­sel

    DATA: lt_selected_rows TYPE lvc_t_row,     " Tabulka vybranÃ½ch Å™Ã¡dkÅ¯ ğŸ“‘
          lv_selected_rows TYPE i,              " PoÄet vybranÃ½ch Å™Ã¡dkÅ¯ ğŸ§®
          lv_index         TYPE i.

    DATA  ls_data_log      TYPE  zpp_api_matrix_l.

    DATA: ls_data_final     TYPE          zpp_api_matrix.  " Struktura pro jeden zÃ¡znam ğŸ“ƒ


    CONSTANTS: lc_log_delete    TYPE string VALUE `DELETE`,
               lc_log_insert    TYPE string VALUE `INSERT`,
               lc_log_update    TYPE string VALUE `UPDATE`,
               lc_mtart_halb    TYPE mtart  VALUE 'HALB',
               lc_unique_value  VALUE 1      TYPE i,
               lc_parts_value_1 VALUE 1      TYPE i,
               lc_parts_value_2 VALUE 2      TYPE i.

    CLEAR            lt_selected_rows.

    "OdstranÄ›nÃ­ oznaÄenÃ½ch Å™Ã¡dkÅ¯  pÅ™es SAVE ->MusÃ­m udÄ›lat pÅ™ed updatem, tyto Å™Ã¡dky jiÅ¾ nepÅ¯jde oznaÄit
    IF mt_data_final[] IS NOT INITIAL.
      "HledÃ¡m maximÃ¡lnÃ­ hodnotu pro delete
      SELECT MAX( unique_value )
      FROM zpp_api_matrix_l
     INTO @DATA(lv_max_unique_value).

      LOOP AT mt_data_final REFERENCE INTO DATA(lr_data_final).
        DELETE FROM zpp_api_matrix
     WHERE sap_id = @lr_data_final->sap_id
       AND werks  = @lr_data_final->werks
       AND api_id = @lr_data_final->api_id
       AND charg  = @lr_data_final->charg.

        " Pokud doÅ¡lo k odstranÄ›nÃ­, pÅ™idÃ¡m hlÃ¡Å¡enÃ­ do logÅ¯
        IF sy-subrc = 0.
          lv_max_unique_value = lv_max_unique_value + lc_unique_value.
*
          " NaplnÄ›nÃ­ struktury pro ZPP_API_MATRIX_L
          MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.
          ls_data_log-datuv_old         = lr_data_final->datuv.
          ls_data_log-datub_old         = lr_data_final->datub.
          ls_data_log-ernam             = sy-uname.
          ls_data_log-change            = lc_log_delete.
          ls_data_log-change_date       = sy-datum.
          ls_data_log-change_time       = sy-uzeit.
          ls_data_log-unique_value      = lv_max_unique_value.

          " VloÅ¾enÃ­ dat do logovÃ© tabulky
          INSERT INTO zpp_api_matrix_l VALUES ls_data_log.
        ENDIF.
      ENDLOOP.


      "VloÅ¾enÃ­ mt_data do mt_data_final
      INSERT LINES OF mt_data INTO TABLE mt_data_final. "v mt_data_final je pÅ¯vodnÃ­ stav dat.

    ELSE.
      mt_data_final = mt_data.
    ENDIF.

    " Provede se odstranÄ›nÃ­ Å™Ã¡dkÅ¯ jeÅ¡tÄ› pÅ™ed loopem ze starÃ©ho mt_data_final.

    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.



    " UPDATE a INSERT po DELETE, protoÅ¾e Å™Ã¡dky odstranÄ›nÃ© jiÅ¾ neoznaÄÃ­m
    IF lt_selected_rows[] IS NOT INITIAL.

      "HledÃ¡m maximÃ¡lnÃ­ hodnotu pro UPDATE ( HledÃ¡m po druhÃ© )
      SELECT MAX( unique_value )
      FROM zpp_api_matrix_l
     INTO @lv_max_unique_value.

      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
        lv_index = lr_selected_data->index.

        "READ#
        lr_data_final = REF #( mt_data_final[ lv_index ] ).

        IF  lr_data_final IS NOT INITIAL.

*ğŸ“ MusÃ­ se provÃ©st filtrace jen tÄ›ch dat, kterÃ© jsou VPOL. V testovacÃ­ch pÅ™Ã­padÄ›ch to bude FERT, pozdÄ›ji zaloÅ¾Ã­m vÃ­ce pÅ™Ã­padÅ¯ ğŸ” ğŸ”‘
* Kontrola existence MTART = VPOL
          IF sy-subrc = 0.
* TOM: SELECT SINGLE MTART
            SELECT SINGLE mtart
              FROM mara
              INTO @DATA(lv_mara)
              WHERE matnr = @lr_data_final->api_id
              AND   mtart = @lc_mtart_halb.         " â— ZmÄ›nit na VPOL u zÃ¡kaznÃ­ka

            IF sy-subrc = 0.

              " Beru jen ty data tÄ›ch materiÃ¡lÅ¯, kterÃ© chci zobrazit pÅ™i vloÅ¾enÃ­
              SELECT * FROM makt
               INTO CORRESPONDING FIELDS OF TABLE lt_makt_matnr
               WHERE (  matnr = lr_data_final->sap_id
               OR    matnr = lr_data_final->api_id )
               AND  ( spras = sy-langu
               OR    spras = 'E' ).

              CLEAR ls_data_log.

              MOVE-CORRESPONDING lr_data_final->* TO ls_data_final.

              " VloÅ¾enÃ­ novÃ©ho Å™Ã¡dku do ZPP_API_MATRIX
              INSERT INTO zpp_api_matrix VALUES ls_data_final.

              IF sy-subrc = 0.

                lr_data_final->history = `I`.

                lv_max_unique_value = lv_max_unique_value  + lc_unique_value.

**âœï¸ Pokud nemÃ¡ mt_data krÃ¡tkÃ½ text materiÃ¡lu k SAP_ID

                DATA(lr_makt_matnr) = REF #( lt_makt_matnr[ matnr = lr_data_final->sap_id spras = sy-langu ] OPTIONAL ).

                IF lr_makt_matnr IS INITIAL.
                  lr_makt_matnr    = REF #( lt_makt_matnr[ matnr = lr_data_final->sap_id  ] OPTIONAL ).
                ENDIF.

* TOM: pokd ta reference nebude ani po druhÃ©m ÄtenÃ­ naplnÄ›nÃ¡, tak ti to tady spadne
*                  lr_data->maktx = COND #( WHEN lr_makt_matnr IS NOT INITIAL
*                                           THEN lr_makt_matnr->maktx
*                                           ELSE space ).

                IF lr_makt_matnr IS NOT INITIAL.
                  lr_data_final->maktx = lr_makt_matnr->maktx.
                ELSE.
                  lr_data_final->maktx = space.
                ENDIF.

*âœï¸ Pokud nemÃ¡ mt_data krÃ¡tkÃ½ text materiÃ¡lu k API_ID
                lr_makt_matnr  = REF #( lt_makt_matnr[  matnr = lr_data_final->api_id spras = sy-langu ] OPTIONAL ).

                IF lr_makt_matnr IS INITIAL.
                  lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data_final->api_id ] OPTIONAL ).
                ENDIF.

* TOM: pokd ta reference nebude ani po druhÃ©m ÄtenÃ­ naplnÄ›nÃ¡, tak ti to tady spadne
*                  lr_data->api_name = COND #( WHEN lr_makt_matnr IS NOT INITIAL
*                                           THEN lr_makt_matnr->maktx
*                                           ELSE space ).

                IF lr_makt_matnr IS NOT INITIAL.
                  lr_data_final->api_name = lr_makt_matnr->maktx.
                ELSE.
                  lr_data_final->api_name = space.
                ENDIF.

*âœï¸ DoplnÄ›nÃ­ destinace pomocÃ­ splitu a readu
                IF lr_data_final->maktx IS NOT INITIAL.

                  DATA(lv_string) = lr_data_final->maktx.
                  SPLIT lv_string AT '(' INTO TABLE DATA(lt_parts).

                  DATA(lv_substring) = lt_parts[ lc_parts_value_2 ].

                  SPLIT lv_substring AT ')' INTO TABLE lt_parts.
                  lv_substring = lt_parts[ lc_parts_value_1 ].

                  lr_data_final->destination = lv_substring.
                ENDIF.

                " NaplnÄ›nÃ­ struktury pro ZPP_API_MATRIX_L
                MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

                ls_data_log-ernam             = sy-uname.
                ls_data_log-change            = lc_log_insert.
                ls_data_log-change_date       = sy-datum.
                ls_data_log-change_time       = sy-uzeit.
                " SeÅ™adÃ­m si tabulku tak, abych naÅ¡el nejvyÅ¡Å¡Ã­ hodnotu unikÃ¡tnÃ­ hodnoty.

                ls_data_log-unique_value      = lv_max_unique_value.

                " VloÅ¾enÃ­ dat do logovÃ© tabulky
                INSERT INTO zpp_api_matrix_l VALUES ls_data_log.

              ELSE. " NemÅ¯Å¾e bÃ½t vloÅ¾en, protoÅ¾e uÅ¾ je v databÃ¡zi, ale mÅ¯Å¾e bÃ½t updated
*                MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t vloÅ¾en.|  TYPE 'I'.

                IF lr_data_final->datuv <> ls_data_log-datuv_old OR lr_data_final->datub <> ls_data_log-datub_old.
                  IF sy-subrc = 0.

                    UPDATE zpp_api_matrix
                SET datuv = @lr_data_final->datuv,
                    datub = @lr_data_final->datub
                WHERE sap_id = @lr_data_final->sap_id
                  AND werks  = @lr_data_final->werks
                  AND api_id = @lr_data_final->api_id
                  AND charg  = @lr_data_final->charg.

                    IF sy-subrc = 0.
                      lr_data_final->history = `U`.
                      MESSAGE |Data byla pozmÄ›nÄ›na a vloÅ¾ena do databÃ¡ze.|  TYPE 'I'.

                      " NaplnÄ›nÃ­ struktury pro ZPP_API_MATRIX_L
                      MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

                      ls_data_log-ernam             = sy-uname.
                      ls_data_log-change            = lc_log_update.
                      ls_data_log-change_date       = sy-datum.
                      ls_data_log-change_time       = sy-uzeit.
                      " SeÅ™adÃ­m si tabulku tak, abych naÅ¡el nejvyÅ¡Å¡Ã­ hodnotu unikÃ¡tnÃ­ hodnoty.

                      ls_data_log-unique_value      = lv_max_unique_value.

                      INSERT INTO zpp_api_matrix_l VALUES ls_data_log.

                    ELSE.
                      MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nebyl uloÅ¾en do databÃ¡ze.|  TYPE 'I'.

                    ENDIF.

                  ENDIF.
                ENDIF.
              ENDIF.

            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
      " Na konci chci zobrzait vÃ½sledky do ALV
      mt_data = mt_data_final.
    ENDIF.

  ENDMETHOD.

*  METHOD insert_row.
*
*    DATA:
*      " Tabulky pro Makt ğŸ“‘
*      lt_makt_matnr     TYPE TABLE OF makt,  " Tabulka materiÃ¡lovÃ½ch ÄÃ­sel ğŸ·ï¸
*
*      " Tabulka pro vybranÃ© Å™Ã¡dky a promÄ›nnÃ© pro poÄet Å™Ã¡dkÅ¯ ğŸ“Š
*      lt_selected_rows  TYPE lvc_t_row,     " Tabulka vybranÃ½ch Å™Ã¡dkÅ¯ ğŸ“‘
*      lv_selected_rows  TYPE i,              " PoÄet vybranÃ½ch Å™Ã¡dkÅ¯ ğŸ§®
*      lv_index          TYPE i,
*
*      " PromÄ›nnÃ© pro matkl a dalÅ¡Ã­ hodnoty ğŸ› ï¸
*      lv_mtart          TYPE matkl,          " KÃ³d materiÃ¡lovÃ© kategorie ğŸ“¦
*
*      " Data pro log tabulku ğŸ“
*      ls_data_log       TYPE zpp_api_matrix_l,  " LogovÃ¡ struktura ğŸ—‚ï¸
*
*      " Tabulka a struktura pro zÃ¡znamy z tabulky zpp_api_matrix ğŸ“„
*      lt_zpp_api_matrix TYPE TABLE OF zpp_api_matrix,  " Tabulka zÃ¡znamÅ¯ ze zpp_api_matrix ğŸ–¥ï¸
*      ls_data           TYPE          zpp_api_matrix.  " Struktura pro jeden zÃ¡znam ğŸ“ƒ
*
*
*    " Konstanta pro vloÅ¾enÃ­ dat ğŸ’¾
*    CONSTANTS: lc_log_insert    TYPE char40 VALUE 'INSERT_DATA',
*               lc_parts_value_1 VALUE 1      TYPE i,
*               lc_parts_value_2 VALUE 2      TYPE i,
*               lc_index_1       VALUE 1      TYPE i,
*               lc_unique_value  VALUE 1      TYPE i,
*               lc_mtart_halb    VALUE 'HALB' TYPE mtart.
*
*    CLEAR lt_selected_rows.
*
*    CALL METHOD mo_grid->get_selected_rows
*      IMPORTING
*        et_index_rows = lt_selected_rows.
*
*    IF lt_selected_rows[] IS NOT INITIAL.
*
*      SELECT MAX( unique_value )
*     FROM zpp_api_matrix_l
*     INTO @DATA(lv_max_unique_value).
*
*      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
*
*        lv_index = lr_selected_data->index.
*
*        DATA(lr_data) = REF #( mt_data[ lv_index ] ).
*
** TOM: IF lr_data is not initial, nebo sy-subrc je 0
*        IF  lr_data IS NOT INITIAL.
*
*          IF lr_data->datuv <= lr_data->datub.
*
**ğŸ“ MusÃ­ se provÃ©st filtrace jen tÄ›ch dat, kterÃ© jsou VPOL. V testovacÃ­ch pÅ™Ã­padÄ›ch to bude FERT, pozdÄ›ji zaloÅ¾Ã­m vÃ­ce pÅ™Ã­padÅ¯ ğŸ” ğŸ”‘
** Kontrola existence MTART = VPOL
*            IF sy-subrc = 0.
** TOM: SELECT SINGLE MTART
*              SELECT SINGLE mtart
*                FROM mara
*                INTO @DATA(lv_mara)
*                WHERE matnr = @lr_data->api_id
*                AND   mtart = @lc_mtart_halb.         " â— ZmÄ›nit na VPOL u zÃ¡kaznÃ­ka
*
*              IF sy-subrc = 0.
*
*                " Beru jen ty data tÄ›ch materiÃ¡lÅ¯, kterÃ© chci zobrazit pÅ™i vloÅ¾enÃ­
*                SELECT * FROM makt
*                 INTO CORRESPONDING FIELDS OF TABLE lt_makt_matnr
*                 WHERE (  matnr = lr_data->sap_id
*                 OR    matnr = lr_data->api_id )
*                 AND  ( spras = sy-langu
*                 OR    spras = 'E' ).
*
** TOM: MOVE-CORRESPONDING
*                CLEAR ls_data.
*
*                MOVE-CORRESPONDING lr_data->* TO ls_data.
*
*                " VloÅ¾enÃ­ novÃ©ho Å™Ã¡dku do ZPP_API_MATRIX
*                INSERT INTO zpp_api_matrix VALUES ls_data.
*
*                IF sy-subrc = 0.    " Message, kdyÅ¾ bude bez chyby
*
*                  lv_max_unique_value = lv_max_unique_value  + lc_unique_value.
*
*                  lr_data->status = ''.
*
*                  MESSAGE |OznaÄenÃ© Å™Ã¡dky byly ÃºspÄ›Å¡nÄ› pÅ™idÃ¡ny.| TYPE 'S'.
*
**âœï¸ Pokud nemÃ¡ mt_data krÃ¡tkÃ½ text materiÃ¡lu k SAP_ID
*
*                  DATA(lr_makt_matnr) = REF #( lt_makt_matnr[ matnr = lr_data->sap_id spras = sy-langu ] OPTIONAL ).
*
*                  IF lr_makt_matnr IS INITIAL.
*                    lr_makt_matnr    = REF #( lt_makt_matnr[ matnr = lr_data->sap_id  ] OPTIONAL ).
*                  ENDIF.
*
** TOM: pokd ta reference nebude ani po druhÃ©m ÄtenÃ­ naplnÄ›nÃ¡, tak ti to tady spadne
**                  lr_data->maktx = COND #( WHEN lr_makt_matnr IS NOT INITIAL
**                                           THEN lr_makt_matnr->maktx
**                                           ELSE space ).
*
*                  IF lr_makt_matnr IS NOT INITIAL.
*                    lr_data->maktx = lr_makt_matnr->maktx.
*                  ELSE.
*                    lr_data->maktx = space.
*                  ENDIF.
*
**âœï¸ Pokud nemÃ¡ mt_data krÃ¡tkÃ½ text materiÃ¡lu k API_ID
*                  lr_makt_matnr  = REF #( lt_makt_matnr[  matnr = lr_data->api_id spras = sy-langu ] OPTIONAL ).
*
*                  IF lr_makt_matnr IS INITIAL.
*                    lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->api_id ] OPTIONAL ).
*                  ENDIF.
*
** TOM: pokd ta reference nebude ani po druhÃ©m ÄtenÃ­ naplnÄ›nÃ¡, tak ti to tady spadne
**                  lr_data->api_name = COND #( WHEN lr_makt_matnr IS NOT INITIAL
**                                           THEN lr_makt_matnr->maktx
**                                           ELSE space ).
*
*                  IF lr_makt_matnr IS NOT INITIAL.
*                    lr_data->api_name = lr_makt_matnr->maktx.
*                  ELSE.
*                    lr_data->api_name = space.
*                  ENDIF.
*
**âœï¸ DoplnÄ›nÃ­ destinace pomocÃ­ splitu a readu
*                  IF lr_data->maktx IS NOT INITIAL.
*
*                    DATA(lv_string) = lr_data->maktx.
*                    SPLIT lv_string AT '(' INTO TABLE DATA(lt_parts).
*
*                    DATA(lv_substring) = lt_parts[ lc_parts_value_2 ].
*
*                    SPLIT lv_substring AT ')' INTO TABLE lt_parts.
*                    lv_substring = lt_parts[ lc_parts_value_1 ].
*
*                    lr_data->destination = lv_substring.
*                  ENDIF.
*
*                  " NaplnÄ›nÃ­ struktury pro ZPP_API_MATRIX_L
*                  MOVE-CORRESPONDING lr_data->* TO ls_data_log.
*
*                  ls_data_log-ernam             = sy-uname.
*                  ls_data_log-change            = lc_log_insert.
*                  ls_data_log-change_date       = sy-datum.
*                  ls_data_log-change_time       = sy-uzeit.
*                  " SeÅ™adÃ­m si tabulku tak, abych naÅ¡el nejvyÅ¡Å¡Ã­ hodnotu unikÃ¡tnÃ­ hodnoty.
*
*                  ls_data_log-unique_value      = lv_max_unique_value.
*
*                  " VloÅ¾enÃ­ dat do logovÃ© tabulky
*                  INSERT INTO zpp_api_matrix_l VALUES ls_data_log.
*
*                ELSE. " Doplnit message, kdyÅ¾ bude Å¡patnÃ© vloÅ¾enÃ­
**                  lr_data->status = 'X'.
** TOM: Doplnit message, kdyÅ¾ bude Å¡patnÃ© vloÅ¾enÃ­
*                  MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t vloÅ¾en do databÃ¡ze.|  TYPE 'I'.
*                ENDIF.
*              ELSE.
**            MESSAGE |Å˜Ã¡dek ÄÃ­slo { sy-tabix } obsahuje SAP_ID { lr_data->sap_id }, kterÃ½ nemÃ¡ druh materiÃ¡lu VPOL.|  TYPE 'I'.
*                lr_data->status = ''.
*              ENDIF.
*            ENDIF.
*          ELSE.
*            MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t vloÅ¾en. FinÃ¡lnÃ­ platnost certifikÃ¡tu musÃ­ bÃ½t vÄ›tÅ¡Ã­ neÅ¾ poÄÃ¡teÄnÃ­ platnost certifikÃ¡tu.|  TYPE 'I'.
*          ENDIF.
*        ELSE.
*          MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t pÅ™idÃ¡n. KlÃ­ÄovÃ¡ pole nejsou vyplnÄ›na.|  TYPE 'I'.
*          lr_data->status = ''.
*        ENDIF.
*      ENDLOOP.
*    ELSE.
*      MESSAGE |OznaÄte Å™Ã¡dky, kterÃ© majÃ­ bÃ½t vloÅ¾eny do databÃ¡ze.|  TYPE 'I'.
*    ENDIF.
*
*  ENDMETHOD.


*  METHOD update.
*
*    DATA:
*      " Tabulka pro vybranÃ© Å™Ã¡dky v ALV gridu ğŸ“Š
*      lt_selected_rows  TYPE lvc_t_row,
*
*      " PoÄet vybranÃ½ch Å™Ã¡dkÅ¯ ğŸ”¢
*      lv_selected_rows  TYPE i,
*
*      lv_index          TYPE i,
*
*      " Tabulka pro zÃ¡znamy z tabulky zpp_api_matrix ğŸ“‹
*      lt_zpp_api_matrix TYPE TABLE OF zpp_api_matrix,
*
*      " JednotlivÃ½ zÃ¡znam z tabulky zpp_api_matrix ğŸ’¼
*      ls_data           TYPE ty_zpp_api_matrix_str,
*
*      " Tabulka pro zmÄ›ny v datech ğŸ“
*      lt_changes        TYPE zpp_api_matrix,
*
*      " LogovÃ¡ tabulka pro sledovÃ¡nÃ­ zmÄ›n v datech ğŸ“ˆ
*      ls_data_log       TYPE zpp_api_matrix_l.
*
*
*    " KonstantnÃ­ hodnota pro logovÃ¡nÃ­ aktualizacÃ­ ğŸ—‚ï¸
*    CONSTANTS: lc_log_update   TYPE char40 VALUE 'UPDATE_DATA',  " KÃ³d pro logovÃ¡nÃ­ aktualizace ğŸ”„
*               lc_index_1      TYPE i      VALUE 1,
*               lc_unique_value TYPE i      VALUE 1.
*
*    CLEAR lt_selected_rows.
*
*    CALL METHOD mo_grid->get_selected_rows
*      IMPORTING
*        et_index_rows = lt_selected_rows.
*
*    IF lt_selected_rows[] IS NOT INITIAL.
*
** TOM: opravdu potÅ™ebuji dalÅ¡Ã­ promÄ›nnou?
*      SELECT MAX( unique_value )
*      FROM zpp_api_matrix_l
*     INTO @DATA(lv_max_unique_value).
*
*      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
*        lv_index = lr_selected_data->index.
*
*        DATA(lr_data) = REF #( mt_data[ lv_index ] ).
*
** TOM: IF lr_data is not initial, nebo sy-subrc je 0
*        IF sy-subrc = 0.                        " Pokud nejsou vyplnÄ›na klÃ­ÄovÃ¡ pole
*          IF lr_data->datuv <= lr_data->datub . " MusÃ­ bÃ½t platnÃ½ certifikÃ¡t
*
*            "Selectuji aÅ¾ v loopu pro zÃ­skÃ¡nÃ­ pÅ¯vodnÃ­ho data
*            SELECT *
*             FROM zpp_api_matrix
*             INTO TABLE lt_zpp_api_matrix
*              WHERE sap_id = lr_data->sap_id
*              AND   werks  = lr_data->werks
*              AND   charg  = lr_data->charg
*              AND   api_id = lr_data->api_id.
*
*            "update by mÄ›lo bÃ½t moÅ¾nÃ© jen tehdy, pokud doÅ¡lo ke zmÄ›nÄ› data.
*            ls_data_log-datuv_old         = VALUE #( lt_zpp_api_matrix[ sap_id   = lr_data->sap_id
*                                                                     werks       = lr_data->werks
*                                                                     api_id      = lr_data->api_id
*                                                                     charg       = lr_data->charg ]-datuv OPTIONAL ).
*
*            ls_data_log-datub_old          = VALUE #( lt_zpp_api_matrix[ sap_id  = lr_data->sap_id
*                                                                     werks       = lr_data->werks
*                                                                     api_id      = lr_data->api_id
*                                                                     charg       = lr_data->charg ]-datub OPTIONAL ).
*
*            " Pokud byly zmÄ›nÄ›ny alespoÅˆ jedny data, dojde k update.
*            IF lr_data->datuv <> ls_data_log-datuv_old OR lr_data->datub <> ls_data_log-datub_old.
*              IF sy-subrc = 0.
*
*                UPDATE zpp_api_matrix
*            SET datuv = @lr_data->datuv,
*                datub = @lr_data->datub
*            WHERE sap_id = @lr_data->sap_id
*              AND werks  = @lr_data->werks
*              AND api_id = @lr_data->api_id
*              AND charg  = @lr_data->charg.
*
*                IF sy-subrc = 0.
*                  MESSAGE |Data byla pozmÄ›nÄ›na a vloÅ¾ena do databÃ¡ze.|  TYPE 'S'.
*
*                  lv_max_unique_value = lv_max_unique_value  + lc_unique_value.
*
*                  " NaplnÄ›nÃ­ struktury pro ZPP_API_MATRIX_L
*                  MOVE-CORRESPONDING lr_data->* TO ls_data_log.
*
*                  ls_data_log-ernam             = sy-uname.
*                  ls_data_log-change            = lc_log_update.
*                  ls_data_log-change_date       = sy-datum.
*                  ls_data_log-change_time       = sy-uzeit.
*
*                  ls_data_log-unique_value      = lv_max_unique_value.
*
*                  " VloÅ¾enÃ­ dat do logovÃ© tabulky
*                  INSERT INTO zpp_api_matrix_l VALUES ls_data_log.
*                ELSE.
*
*                  MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t pozmÄ›nÄ›n.|  TYPE 'I'.
*                ENDIF.
*              ENDIF.
*            ELSE.
*              MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } obsahuje nezmÄ›nÄ›nÃ¡ data.|  TYPE 'I'.
*
*            ENDIF.
*          ELSE.
*            MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t upraven. FinÃ¡lnÃ­ platnost certifikÃ¡tu musÃ­ bÃ½t vÄ›tÅ¡Ã­ neÅ¾ poÄÃ¡teÄnÃ­ platnost certifikÃ¡tu.|  TYPE 'I'.
*          ENDIF.
*        ELSE.
*          MESSAGE |Å˜Ã¡dek ÄÃ­slo { lv_index } nemohl bÃ½t upraven. KlÃ­ÄovÃ¡ pole nejsou vyplnÄ›na.|  TYPE 'I'.
*        ENDIF.
*      ENDLOOP.
*    ELSE.
*      MESSAGE |OznaÄte Å™Ã¡dky, kterÃ© majÃ­ bÃ½t upraveny.|  TYPE 'I'.
*    ENDIF.
*  ENDMETHOD.

  METHOD delete.

    DATA: ls_data_final TYPE ty_zpp_api_matrix_str.

    DATA:
      " Tabulka pro vybranÃ© Å™Ã¡dky v ALV gridu ğŸ“Š
      lt_selected_rows  TYPE lvc_t_row,

      " PoÄet vybranÃ½ch Å™Ã¡dkÅ¯ ğŸ”¢
      lv_selected_rows  TYPE i,

      " PromÄ›nnÃ¡ se SAP_ID, kterÃ½ se mÃ¡ vymazat z mt_data
      lv_delete_sap_id  TYPE matnr,

      lv_index          TYPE i,

      " LogovÃ¡ tabulka pro sledovÃ¡nÃ­ zmÄ›n v datech ğŸ“ˆ
      ls_data_log       TYPE zpp_api_matrix_l,

      " Tabulka pro zÃ¡znamy z tabulky zpp_api_matrix ğŸ’¼
      lt_zpp_api_matrix TYPE TABLE OF zpp_api_matrix.

    CONSTANTS: lc_log_delete   TYPE char40 VALUE 'DELETE_DATA',
               lc_index_1      TYPE i VALUE 1,
               lc_unique_value TYPE i VALUE 1.

    CLEAR lt_selected_rows.


    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.

    IF lt_selected_rows[] IS NOT INITIAL.

      "HledÃ¡m maximÃ¡lnÃ­ hodnotu
*      SELECT MAX( unique_value )
*      FROM zpp_api_matrix_l
*     INTO @DATA(lv_max_unique_value).

      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
        lv_index = lr_selected_data->index.

        " PotÅ™ebuji zÃ­skat data, Å¾e doÅ¡lo ke smazÃ¡nÃ­ Å™Ã¡dku a zÃ¡roveÅˆ k jeho smazÃ¡nÃ­ v ALV
        DATA(lr_data) = REF #( mt_data[ lv_index ] ).
        lr_data->history = 'D'.
        MOVE-CORRESPONDING lr_data->* TO ls_data_final.
        APPEND ls_data_final TO mt_data_final.
        CLEAR lr_data->sap_id.


        " VymazÃ¡nÃ­ dat z databÃ¡zovÃ© tabulky
*        DELETE FROM zpp_api_matrix
*         WHERE sap_id = @lr_data->sap_id
*           AND werks  = @lr_data->werks
*           AND api_id = @lr_data->api_id
*           AND charg  = @lr_data->charg.

*        IF sy-subrc = 0.

*          lv_max_unique_value = lv_max_unique_value  + lc_unique_value.

*          MESSAGE |Å˜Ã¡dek byl ÃºspÄ›Å¡nÄ› smazÃ¡n.|  TYPE 'S'.

        " NaplnÄ›nÃ­ struktury pro ZPP_API_MATRIX_L
*          MOVE-CORRESPONDING lr_data->* TO ls_data_log.
*          ls_data_log-datuv_old         = lr_data->datuv.
*          ls_data_log-datub_old         = lr_data->datub.
*          ls_data_log-ernam             = sy-uname.
*          ls_data_log-change            = lc_log_delete.
*          ls_data_log-change_date       = sy-datum.
*          ls_data_log-change_time       = sy-uzeit.

        " Hodnota se po ÃºspÄ›Å¡nÃ©m delete zvyÅ¡uje o jednu hodnotu
*          ls_data_log-unique_value      = lv_max_unique_value.

        " VloÅ¾enÃ­ dat do logovÃ© tabulky
*          INSERT INTO zpp_api_matrix_l VALUES ls_data_log.

        " NenÃ­ tÅ™eba psÃ¡t logickÃ© kroky, prostÄ› jen vymaÅ¾eme lr_data-> sap_id
*          CLEAR lr_data->sap_id.

*        ELSE.
*          CLEAR lr_data->sap_id.
* TOM: MESSAGE?
*          IF  lr_data->sap_id IS NOT INITIAL  AND lr_data->werks IS NOT INITIAL
*            AND lr_data->charg IS NOT INITIAL AND lr_data->api_id  IS NOT INITIAL.      " KlÃ­ÄovÃ¡ pole jsou vyplnÄ›na, pravdÄ›podobnÄ› jsou v databÃ¡zi
*            MESSAGE |Å˜Ã¡dek ÄÃ­slo { sy-tabix } nemohl bÃ½t smazÃ¡n z databÃ¡ze.|  TYPE 'I'. " Pokud dojde k chybÄ› v odstranÄ›nÃ­
*          ELSE.
*            MESSAGE |Å˜Ã¡dek ÄÃ­slo { sy-tabix } byl odebrÃ¡t.|  TYPE 'S'.                  " Pokud zpravidla odstraÅˆuji prÃ¡zdnÃ© Å™Ã¡dky v ALV, nechci vyskakovacÃ­ okno.
        "Pokud nechÃ¡m data v SAP_ID a chci smazat nevyplnÄ›nÃ½ Å™Ã¡dek
*          ENDIF.
*        ENDIF.

      ENDLOOP.
      "SmazÃ¡nÃ­ z ALV
      DELETE mt_data WHERE sap_id IS INITIAL.
*    ELSE.
*      MESSAGE |OznaÄte Å™Ã¡dky, kterÃ© majÃ­ bÃ½t odstranÄ›ny z databÃ¡ze.|  TYPE 'I'.
    ENDIF.
  ENDMETHOD.

  METHOD display.
    CALL SCREEN 0100.
  ENDMETHOD.

  METHOD alv_create.

    DATA: lt_fcat     TYPE        lvc_t_fcat,
          ls_fcat     TYPE        lvc_s_fcat,
          ls_layout   TYPE        lvc_s_layo,
          lr_fieldcat TYPE REF TO lvc_s_fcat,
          ls_exclude  TYPE        ui_func,
          gt_exclude  TYPE        ui_functions.

    DATA: ls_stylerow TYPE        lvc_s_styl,             " Styl pro Å™Ã¡dek v ALV
          lr_listrow  TYPE REF TO ty_zpp_api_matrix_str.  " Reference na strukturu typu ty_zpp_api_matrix_str

    " ğŸ“Œ VytvoÅ™enÃ­ kontejneru s nÃ¡zvem ALV_GRID
    IF mo_custom_container IS INITIAL.
      CREATE OBJECT mo_custom_container
        EXPORTING
          container_name = 'ALV_GRID'.
      CREATE OBJECT mo_grid
        EXPORTING
          i_parent = mo_custom_container.

      " ğŸ“Œ ZaloÅ¾enÃ­ fieldcatalogu pro zobrazenÃ­ ALV
      CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
        EXPORTING
          i_structure_name       = 'ZPP_API_MATRIX_STR'   " Struktura pro ALV
        CHANGING
          ct_fieldcat            = lt_fcat
        EXCEPTIONS
          inconsistent_interface = 1
          program_error          = 2
          OTHERS                 = 3.

*âœï¸ ZajiÅ¡tÄ›nÃ­ editovatelnosti prÃ¡zdnÃ½ch Å™Ã¡dkÅ¯
      LOOP AT mt_data REFERENCE INTO lr_listrow.
        CLEAR lr_listrow->cellstyles.

        " PodmÃ­nka pro zobrazenÃ­ editace
        lr_listrow->cellstyles = COND #(
    WHEN (    lr_listrow->sap_id IS NOT INITIAL OR lr_listrow->werks IS NOT INITIAL
         OR   lr_listrow->api_id IS NOT INITIAL OR lr_listrow->charg IS NOT INITIAL )
         AND   lr_listrow->status = ''
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )
    WHEN ( lr_listrow->sap_id IS INITIAL AND lr_listrow->werks IS INITIAL
         AND   lr_listrow->api_id IS INITIAL AND lr_listrow->charg IS INITIAL )
         AND   lr_listrow->status = ''
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )


    ELSE lr_listrow->cellstyles ).

      ENDLOOP.

      LOOP AT lt_fcat REFERENCE INTO lr_fieldcat.
        "  ğŸ“Œ UmoÅ¾nit editaci pro DATUV a DATUB a pÅ™ejmenovÃ¡nÃ­ sloupcÅ¯.
        CASE lr_fieldcat->fieldname.
          WHEN 'SAP_ID'.

            lr_fieldcat->coltext = 'SAP_ID'.            " ZmÄ›na nÃ¡zvu sloupce SAP_ID
            lr_fieldcat->key = 'X'.
            lr_fieldcat->edit = 'X'.
          WHEN 'WERKS'.
            lr_fieldcat->coltext = 'ZÃ¡vod'.             " ZmÄ›na nÃ¡zvu sloupce WERKS
            lr_fieldcat->key = 'X'.
            lr_fieldcat->edit = 'X'.
          WHEN 'MAKTX'.
            lr_fieldcat->coltext = 'NÃ¡zev'.             " ZmÄ›na nÃ¡zvu sloupce MAKTX
*            lr_fieldcat->edit = 'X'.
          WHEN 'DESTINATION'.
            lr_fieldcat->coltext = 'Destinace'.         " ZmÄ›na nÃ¡zvu sloupce DESTINATION
*            lr_fieldcat->edit = 'X'.
          WHEN 'INN_DEVICE'.
            lr_fieldcat->coltext = 'INN zaÅ™azenÃ­'.       " ZmÄ›na nÃ¡zvu sloupce INN_DEVICE
*            lr_fieldcat->edit = 'X'.
          WHEN 'MZP'.
            lr_fieldcat->coltext = 'MZP'.               " ZmÄ›na nÃ¡zvu sloupce MZP
*            lr_fieldcat->edit = 'X'.
          WHEN 'CHARG'.
            lr_fieldcat->coltext = 'Å arÅ¾e'.    " ZmÄ›na nÃ¡zvu sloupce CHARG
            lr_fieldcat->key = 'X'.
            lr_fieldcat->edit = 'X'.
          WHEN 'PRODUCTION_PLANT'.
            lr_fieldcat->coltext = 'MÃ­sto vÃ½rovy'.      " ZmÄ›na nÃ¡zvu sloupce PRODUCTION_PLANT
*            lr_fieldcat->edit = 'X'.
          WHEN 'MZP_CSP'.
            lr_fieldcat->coltext = 'MZP ÄŒSP'.           " ZmÄ›na nÃ¡zvu sloupce MZP_CSP
*            lr_fieldcat->edit = 'X'.
          WHEN 'API_ID'.
            lr_fieldcat->edit = 'X'.
            lr_fieldcat->coltext = 'API ID'.            " ZmÄ›na nÃ¡zvu sloupce API_ID
            lr_fieldcat->key = 'X'.
          WHEN 'API_NAME'.
            lr_fieldcat->coltext = 'API nÃ¡zev'.         " ZmÄ›na nÃ¡zvu sloupce API_NAME
*            lr_fieldcat->edit = 'X'.
          WHEN 'MZP_BC'.
            lr_fieldcat->coltext = 'MZP BC'.            " ZmÄ›na nÃ¡zvu sloupce MZP_BC
*            lr_fieldcat->edit = 'X'.
          WHEN 'DATUV'.
            lr_fieldcat->coltext = 'Platnost od'.       " ZmÄ›na nÃ¡zvu sloupce DATUV
            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
          WHEN 'DATUV_OLD'.
            lr_fieldcat->coltext = 'Platnost od(OLD)'.  " ZmÄ›na nÃ¡zvu sloupce DATUV_OLD
*            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'DATUB'.
            lr_fieldcat->coltext = 'Platnost do'.       " ZmÄ›na nÃ¡zvu sloupce DATUB
            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
          WHEN 'DATUB_OLD'.
            lr_fieldcat->coltext = 'Platnost do(OLD)'.       " ZmÄ›na nÃ¡zvu sloupce DATUB
*            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'GRIS_RELEVATION'.
            lr_fieldcat->coltext = 'GRIS relevance'.    " ZmÄ›na nÃ¡zvu sloupce GRIS_RELEVATION
*            lr_fieldcat->edit = 'X'.
          WHEN 'VERIFY'.
            lr_fieldcat->coltext = 'Platnost'.          " ZmÄ›na nÃ¡zvu sloupce VERIFY
            IF r_all <> 'X'.
              lr_fieldcat->no_out = 'X'.
            ENDIF.
*            lr_fieldcat->edit = 'X'.
          WHEN 'STATUS'.
            lr_fieldcat->no_out = 'X'.
          WHEN 'UNIQUE_VALUE'.
            lr_fieldcat->no_out = 'X'.


        ENDCASE.
      ENDLOOP.

      DELETE lt_fcat WHERE fieldname IS INITIAL.
      ls_exclude = cl_gui_alv_grid=>mc_fc_views.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_info.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_print.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_check.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
      APPEND ls_exclude TO gt_exclude.

      ls_layout-stylefname = 'CELLSTYLES'.
      ls_layout-sel_mode   = 'A'.
      ls_layout-zebra      = 'X'.
      ls_layout-cwidth_opt = 'X'.
      gs_variant-report    = sy-repid.
      gs_variant-username  = sy-uname.

      " ğŸ“Œ ZobrazenÃ­ modulÃ¡rnÃ­ tabulky do ALV
      CALL METHOD mo_grid->set_table_for_first_display
        EXPORTING
          is_variant                    = gs_variant
          is_layout                     = ls_layout
          i_save                        = 'A'
          it_toolbar_excluding          = gt_exclude
        CHANGING
          it_fieldcatalog               = lt_fcat
          it_outtab                     = mt_data
        EXCEPTIONS
          invalid_parameter_combination = 1
          program_error                 = 2
          too_many_lines                = 3
          OTHERS                        = 4.

      IF sy-subrc EQ 0.

        SET HANDLER handle_toolbar                        FOR mo_grid.
        SET HANDLER handle_user_command                   FOR mo_grid.
        SET HANDLER handle_data_changed                   FOR mo_grid.

        CALL METHOD mo_grid->set_toolbar_interactive.

        CALL METHOD mo_grid->register_edit_event
          EXPORTING
            i_event_id = cl_gui_alv_grid=>mc_evt_enter.

        CALL METHOD mo_grid->set_focus
          EXPORTING
            control = mo_grid.
      ENDIF.
    ELSE.
      alv_refresh( ).
    ENDIF.
  ENDMETHOD.

  METHOD alv_refresh.

    DATA  ls_stable   TYPE lvc_s_stbl.

    ls_stable-row = 'X'.
    ls_stable-col = 'X'.

    CALL METHOD mo_grid->refresh_table_display
      EXPORTING
        is_stable = ls_stable.
  ENDMETHOD.

  METHOD alv_edit.

    DATA:

      lt_selected_rows TYPE lvc_t_row,
      lv_selected_rows TYPE i,
      lv_index         TYPE i.

    DATA: ls_stylerow TYPE        lvc_s_styl,             " Styl pro Å™Ã¡dek v ALV
          lr_listrow  TYPE REF TO ty_zpp_api_matrix_str.  " Reference na strukturu typu ty_zpp_api_matrix_str


    CLEAR lt_selected_rows.

    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.

*âœï¸ ZajiÅ¡tÄ›nÃ­ editovatelnosti prÃ¡zdnÃ½ch Å™Ã¡dkÅ¯
    IF lt_selected_rows[] IS NOT INITIAL.
      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
        lv_index = lr_selected_data->index.

        lr_listrow = REF #( mt_data[ lv_index ] ).

        " PodmÃ­nka pro zobrazenÃ­ editace
        lr_listrow->cellstyles = COND #(
    WHEN (    lr_listrow->sap_id IS INITIAL OR lr_listrow->werks IS INITIAL
         OR   lr_listrow->api_id IS INITIAL OR lr_listrow->charg IS INITIAL )
         AND   lr_listrow->status = ''
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )
    WHEN lr_listrow->sap_id IS NOT INITIAL
         AND lr_listrow->werks IS NOT INITIAL
         AND lr_listrow->api_id IS NOT INITIAL
         AND lr_listrow->charg IS NOT INITIAL
         AND lr_listrow->status = 'X'
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )

    ELSE    VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
      ) ).

*âœï¸ ZjiÅ¡enÃ­ platnosti certifikÃ¡tu
        IF r_all = 'X'.
          lr_listrow->verify = COND #( WHEN lr_listrow->datub >= sy-datum
                                       AND lr_listrow->datuv  <= sy-datum
                                       AND lr_listrow->datub  > lr_listrow->datuv
                                       AND lr_listrow->datuv IS NOT INITIAL
                                       THEN icon_green_light
                                       ELSE icon_red_light ).
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.

  METHOD handle_data_changed.

    DATA: lt_error  TYPE TABLE OF lvc_s_modi, " Tabulka pro chyby
          ls_modi   TYPE lvc_s_modi,          " Struktura pro jeden zÃ¡znam o zmÄ›nÄ›
          ls_error  TYPE lvc_s_modi,          " Struktura pro chybu
          lv_sap_id TYPE matnr,               " SAP ID pro materiÃ¡l
          lv_werks  TYPE werks_d,             " KÃ³d zÃ¡vodu
          lv_api_id TYPE idnrk,               " API ID pro identifikaci
          lv_charg  TYPE charg_d,             " ÄŒÃ­slo Å¡arÅ¾e
          lv_length TYPE i.                   " DÃ©lka promÄ›nnÃ©

    CONSTANTS lc_halb TYPE mtart VALUE 'HALB'.

    " PoÄet Å™Ã¡dkÅ¯ v mt_data
    DATA(lv_lines_data) = lines( mt_data ).

    " ZjiÅ¡tÄ›nÃ­ poÄtu Å™Ã¡dkÅ¯ v zÃ¡znamu
    LOOP AT er_data_changed->mt_good_cells INTO ls_modi.
      IF ls_modi-row_id > lv_lines_data.
        DATA(lv_max_value) = ls_modi-row_id.
      ENDIF.
    ENDLOOP.

    " VypoÄÃ­tÃ¡nÃ­, kolik Å™Ã¡dkÅ¯ se musÃ­ pÅ™idat do mt_data.

    IF lv_max_value IS NOT INITIAL.
      DATA(lv_final_lines) = lv_max_value - lv_lines_data.
      DO lv_final_lines TIMES.
        APPEND INITIAL LINE TO mt_data.
      ENDDO.
    ENDIF.

    LOOP AT er_data_changed->mt_good_cells INTO ls_modi.
      " OvÄ›Å™Ã­me, zda se zmÄ›nila hodnota zÃ¡vodu (SAP_ID)
      CASE ls_modi-fieldname.

        WHEN 'SAP_ID'.
          lv_sap_id = ls_modi-value.
          SELECT SINGLE matnr
            FROM mara
            INTO @DATA(lv_mara)
            WHERE matnr = @lv_sap_id.

          IF sy-subrc <> 0.
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = |NeplatnÃ© SAP_ID na Å™Ã¡dku: { sy-tabix } |
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.

              " MaÅ¾u vÃ½hradnÄ› prvnÃ­ Å™Ã¡dek tabulky, proto bez []
              CLEAR: lt_error, ls_error.

              " ChybnÃ¡ hodnota => pÅ™idÃ¡me do seznamu chyb
            ENDIF.
          ENDIF.
          " OvÄ›Å™Ã­me, zda se zmÄ›nila hodnota zÃ¡vodu (WERKS)
        WHEN 'WERKS'.
          lv_werks = ls_modi-value.

          " Zkontrolujeme, zda zÃ¡vod existuje v tabulce T001W
          SELECT SINGLE werks
            FROM t001w
            INTO @DATA(lv_dummy)
            WHERE werks = @lv_werks.
          IF sy-subrc <> 0.

            " ChybnÃ¡ hodnota => pÅ™idÃ¡me do seznamu chyb
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = 'NeplatnÃ½ zÃ¡vod'
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.

              CLEAR: lt_error, ls_error.
            ENDIF.
          ENDIF.

        WHEN 'CHARG'.

          lv_length = 10.
          lv_charg = ls_modi-value.

          IF strlen( lv_charg ) <> lv_length.

            " ChybnÃ¡ hodnota => pÅ™idÃ¡me do seznamu chyb
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = 'NeplatnÃ© CHARG'
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.
              CLEAR: lt_error, ls_error.
            ENDIF.
          ENDIF.

        WHEN 'API_ID'.
          lv_api_id = ls_modi-value.

          " PoÅ™ebuji kontrolu unikÃ¡tnosti klÃ­ÄovÃ½ch polÃ­, zda nejsou v databÃ¡zi, potÃ© k nim hledÃ¡m dalÅ¡Ã­ informace.
          SELECT SINGLE *
            FROM zpp_api_matrix
            INTO @DATA(ls_keys)
            WHERE sap_id = @lv_sap_id
            AND   werks  = @lv_werks
            AND   charg  = @lv_charg
            AND   api_id = @lv_api_id.

          " Pokud je uÅ¾ stejnÃ½ zÃ¡znam v databÃ¡zi
          IF sy-subrc = 0.
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = 'KlÃ­ÄovÃ¡ pole jsou jiÅ¾ obsaÅ¾ena v databÃ¡zi.'
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.
              CLEAR: lt_error, ls_error.
            ENDIF.
          ELSE.

            SELECT SINGLE matnr
              FROM mara
              INTO @lv_mara
              WHERE matnr = @lv_api_id.

            IF sy-subrc <> 0.
              " ChybnÃ¡ hodnota => pÅ™idÃ¡me do seznamu chyb
              ls_error = ls_modi.
              APPEND ls_error TO lt_error.

              IF lt_error IS NOT INITIAL.
                LOOP AT lt_error INTO ls_modi.
                  CALL METHOD er_data_changed->add_protocol_entry
                    EXPORTING
                      i_msgid     = 'ZMSG'
                      i_msgty     = 'E'
                      i_msgno     = '001'
                      i_msgv1     = 'NeplatnÃ© API_ID'
                      i_fieldname = ls_modi-fieldname
                      i_row_id    = ls_modi-row_id.

                ENDLOOP.
                CLEAR: lt_error, ls_error.
              ENDIF.
            ELSE.
              " Pokud je zÃ¡znam v MATNR, ale nenÃ­ HALB(VPOL u zÃ¡kaznÃ­ka)
              SELECT SINGLE matnr
                FROM mara
                INTO @lv_mara
                WHERE matnr = @lv_api_id
                AND   mtart = @lc_halb.

              IF sy-subrc <> 0.
                ls_error = ls_modi.
                APPEND ls_error TO lt_error.

                IF lt_error IS NOT INITIAL.
                  LOOP AT lt_error INTO ls_modi.
                    CALL METHOD er_data_changed->add_protocol_entry
                      EXPORTING
                        i_msgid     = 'ZMSG'
                        i_msgty     = 'E'
                        i_msgno     = '001'
                        i_msgv1     = 'SAP_ID nenÃ­ typ materiÃ¡lu HALB.'
                        i_fieldname = ls_modi-fieldname
                        i_row_id    = ls_modi-row_id.

                  ENDLOOP.

                  CLEAR: lt_error, ls_error.
                ENDIF.
              ENDIF.


            ENDIF.
          ENDIF.
      ENDCASE.
    ENDLOOP.

  ENDMETHOD.

  METHOD read_popup.

    DATA: lt_selected_rows TYPE lvc_t_row,
          lv_selected_rows TYPE i,
          lv_index         TYPE i.

    IF lt_selected_rows[] IS NOT INITIAL.
      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_rows).

      ENDLOOP.
    ENDIF.

  ENDMETHOD.

  METHOD alv_create_popup.


  ENDMETHOD.


  METHOD display_popup.

  ENDMETHOD.

  METHOD handle_toolbar.

    DATA lr_toolbar TYPE REF TO stb_button.

    " VytvoÅ™enÃ­ novÃ©ho bloku pamÄ›ti pomocÃ­ NEW stb_button( ).
    " Vyhnu se tÃ­m clearu, alokuji si pro kaÅ¾dÃ© new novou instanci
    lr_toolbar = NEW stb_button( ).
    lr_toolbar->butn_type = 3.
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    " Alokace pamÄ›ti pro dalÅ¡Ã­ tlaÄÃ­tka
    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'ADD_ROW'.
    lr_toolbar->icon      = icon_create.
    lr_toolbar->quickinfo = TEXT-000.
    lr_toolbar->text      = TEXT-000.
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'SAVE'.
    lr_toolbar->icon      = icon_create.
    lr_toolbar->quickinfo = TEXT-005.
    lr_toolbar->text      = TEXT-005.
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

*    lr_toolbar = NEW stb_button( ).
*    lr_toolbar->function  = 'INSERT_ROW'.
*    lr_toolbar->icon      = icon_edit_file.
*    lr_toolbar->quickinfo = TEXT-002.
*    lr_toolbar->text      = TEXT-002.
*    APPEND lr_toolbar->* TO e_object->mt_toolbar.
*
*    lr_toolbar = NEW stb_button( ).
*    lr_toolbar->function  = 'ADD'.
*    lr_toolbar->icon      = icon_businav_process.
*    lr_toolbar->quickinfo = TEXT-001.
*    lr_toolbar->text      = TEXT-001.
*    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'DELETE'.
    lr_toolbar->icon      = icon_delete.
    lr_toolbar->quickinfo = TEXT-003.
    lr_toolbar->text      = TEXT-003.
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'HISTORY'.
    lr_toolbar->icon      = icon_alarm.
    lr_toolbar->quickinfo = TEXT-004.
    lr_toolbar->text      = TEXT-004.
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

  ENDMETHOD.

  METHOD handle_user_command.

    DATA: row    TYPE lvc_t_row,
          lt_row TYPE lvc_t_row.

    CASE e_ucomm.
      WHEN  'ADD_ROW'.
        add_row( ).   " pÅ™idej Å™Ã¡dek
        alv_refresh( ).

      WHEN  'SAVE' .
        save_row( ).   "
        alv_edit( ).
        alv_refresh( ).

*      WHEN 'INSERT_ROW'.
*        insert_row( ).   " vloÅ¾ Å™Ã¡dek do databÃ¡ze
*        alv_edit( ).
*        alv_refresh( ).
*
*      WHEN  'ADD'.
*        update( ).   " uloÅ¾
*        alv_edit( ).
*        alv_refresh( ).

      WHEN 'DELETE'.
        delete( ).   " vymaÅ¾
        alv_refresh( ).

      WHEN 'HISTORY'.
        read_popup( ).
        display_popup( ).
    ENDCASE.

  ENDMETHOD.


ENDCLASS.                  "lcl_app IMPLEMENTATION

DATA go_inst TYPE REF TO lcl_app.

MODULE status_0100 OUTPUT.

  SET PF-STATUS 'STATUS_0100'.

  IF r_all = 'X'.
    SET TITLEBAR '0100' .
  ELSEIF r_val = 'X'.
    SET TITLEBAR '0101' .
  ELSE.
    SET TITLEBAR '0102' .
  ENDIF.

  go_inst->alv_create( ).

ENDMODULE.                 " STATUS_0100  OUTPUT

MODULE user_command_0100 INPUT.
  CASE sy-ucomm.
    WHEN 'BACK' OR 'CANC' OR 'EXIT'.
      LEAVE TO SCREEN 0.
  ENDCASE.
ENDMODULE.                 " USER_COMMAND_0100  INPUT


INITIALIZATION.

  CLEAR gs_variant.
  gs_variant-report = sy-repid.

  CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
    EXPORTING
      i_save     = 'A'
    CHANGING
      cs_variant = gs_variant
    EXCEPTIONS
      not_found  = 2.

  IF sy-subrc = 0.
    p_varnt = gs_variant-variant.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_varnt.

  DATA  lv_exit TYPE c.

  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gs_variant
      i_save     = 'A'
    IMPORTING
      e_exit     = lv_exit
      es_variant = gs_variant
    EXCEPTIONS
      not_found  = 2.

  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF lv_exit EQ space.
      p_varnt = gs_variant-variant.
    ENDIF.
  ENDIF.

START-OF-SELECTION.

* ğŸš€
  CREATE OBJECT go_inst.
  go_inst->run( ).