*&---------------------------------------------------------------------*
*& Report ZPP_API_MATRIX_MAINT
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zpp_api_matrix_maint_tmp.


* üìå TABLE:     ZPP_API_MATRIX
* üìå Structure: ZPP_API_MATRIX_STR

TABLES: zpp_api_matrix.

DATA  gs_variant   TYPE          disvariant.
DATA  gv_changed   TYPE          flag.


SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE TEXT-011.
  SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE TEXT-012.
    SELECT-OPTIONS: s_sap_id FOR zpp_api_matrix-sap_id,
                    s_werks  FOR zpp_api_matrix-werks,
                    s_api_id FOR zpp_api_matrix-api_id,
                    s_charg  FOR zpp_api_matrix-charg.
  SELECTION-SCREEN END OF BLOCK b2.

  SELECTION-SCREEN BEGIN OF BLOCK b3 WITH FRAME TITLE TEXT-010.
    PARAMETERS: r_all   RADIOBUTTON GROUP rb1 USER-COMMAND x MODIF ID 002, "User command = prov√°d√≠ refresh
                r_val   RADIOBUTTON GROUP rb1 MODIF ID 002,
                p_val   TYPE datuv DEFAULT sy-datum MODIF ID 001,
                r_inval RADIOBUTTON GROUP rb1 MODIF ID 002.
  SELECTION-SCREEN END OF BLOCK b3.
SELECTION-SCREEN END OF BLOCK b1.

* üìå  layout selection
SELECTION-SCREEN BEGIN OF BLOCK b05 WITH FRAME TITLE TEXT-013.
  PARAMETERS: p_varnt LIKE disvariant-variant.
SELECTION-SCREEN END OF BLOCK b05.


TYPES: BEGIN OF ty_zpp_api_matrix_str.
         INCLUDE    TYPE zpp_api_matrix_str.  " Vlo≈æ√≠ v≈°echna pole z t√©to sttruktury
TYPES:  END OF    ty_zpp_api_matrix_str.


AT SELECTION-SCREEN OUTPUT.
  LOOP AT SCREEN INTO DATA(ls_screen).
    IF ls_screen-group1 = '001'.

      IF r_val = 'X'.
        ls_screen-invisible = 0.  " p_val bude vidƒõt
        ls_screen-active = 1.     " p_val bude aktivn√≠ a editovateln√©

      ELSE.
        ls_screen-invisible = 1.  " p_val nebude vidƒõt
        ls_screen-active = 0.     " p_val nebude aktivn√≠
      ENDIF.

      MODIFY SCREEN FROM ls_screen.
    ENDIF.
  ENDLOOP.


CLASS lcl_app DEFINITION.
  PUBLIC SECTION.

* üìå  P≈ôidat konstanty a ve≈ôejn√° data

    METHODS:
      run,         " üöÄ

      read,        " üï∂Ô∏è
      add_row,     " üöÄ
      save_row,
      delete,      " ‚ùå
      display,     " üí°
      alv_create,  " ‚úÖ
      alv_refresh, " üîÑ
      alv_refresh_popup,
      alv_edit,    " ‚úèÔ∏è

      " zobrazen√≠ tabulky s logy
      read_popup,
      alv_create_popup,
      display_popup,

      handle_toolbar FOR EVENT toolbar OF cl_gui_alv_grid
        IMPORTING e_object e_interactive,

      handle_user_command FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm,

      handle_double_click FOR EVENT double_click OF cl_gui_alv_grid
        IMPORTING e_row e_column es_row_no,

      handle_data_changed FOR EVENT data_changed OF cl_gui_alv_grid
        IMPORTING er_data_changed e_onf4 e_onf4_before e_onf4_after e_ucomm.


  PRIVATE SECTION.

    DATA:
      " Referenƒçn√≠ promƒõnn√© pro ALV Grid a Custom Container üñ•Ô∏è
      mo_grid                   TYPE REF TO cl_gui_alv_grid,                " ALV Grid pro zobrazen√≠ dat v tabulce üìä
      mo_grid_popup             TYPE REF TO cl_gui_alv_grid,                " ALV Grid pro zobrazen√≠ dat v tabulce üìä
      mo_custom_container       TYPE REF TO cl_gui_custom_container,        " Custom Container pro p≈ôizp≈Øsoben√≠ vzhledu üß∞
      mo_custom_container_popup TYPE REF TO cl_gui_custom_container,        " Custom Container pro p≈ôizp≈Øsoben√≠ vzhledu üß∞

      " Tabulky pro data z matrixu zpp_api_matrix üìù
      mt_data                   TYPE TABLE OF ty_zpp_api_matrix_str,        " Hlavn√≠ data pro z√°znamy tabulky zpp_api_matrix_strüìã
      mt_data_final             TYPE TABLE OF ty_zpp_api_matrix_str,        " Hlavn√≠ data pro ulo≈æen√≠ do datab√°ze
      mt_data_history           TYPE TABLE OF ty_zpp_api_matrix_str,        " Uchov√°v√° data po ƒçten√≠

      " Tabulka pro data z log≈Ø zpp_api_matrix üìù
      mt_data_popup             TYPE TABLE OF zpp_api_matrix_l,

      mt_error                  TYPE TABLE OF lvc_s_modi. " Tabulka pro chyby.


ENDCLASS.                          "lcl_app DEFINITION

CLASS lcl_app IMPLEMENTATION.
  METHOD run.

    IF p_varnt IS NOT INITIAL.
      gs_variant-variant = p_varnt.
    ENDIF.

    read( ).
    display( ).
  ENDMETHOD.

  METHOD read.  " üï∂Ô∏è

    DATA:
      " Tabulka pro z√°znamy z tabulky zpp_api_matrix üñ•Ô∏è
      lt_zpp_api_matrix TYPE TABLE OF zpp_api_matrix,

      " Tabulka pro data z ty_zpp_api_matrix_str üìÑ
      lt_data           TYPE TABLE OF ty_zpp_api_matrix_str,

      " Tabulky pro Makt üìë
      lt_makt_matnr     TYPE TABLE OF makt.  " Tabulka materi√°lov√Ωch ƒç√≠sel üè∑Ô∏è

    " Data pro parametry üìä

    CONSTANTS: lc_parts_value_1 VALUE 1 TYPE i,
               lc_parts_value_2 VALUE 2 TYPE i.


" Zkr√°cen√≠ select≈Ø
    DATA(lv_where) = |sap_id IN @s_sap_id AND werks IN @s_werks AND api_id IN @s_api_id AND charg IN @s_charg|.

    CASE 'X'.
      WHEN r_all.

        SELECT *
          FROM zpp_api_matrix
          INTO CORRESPONDING FIELDS OF TABLE @lt_data
            WHERE (lv_where).

      WHEN r_val. " Chci zobrazit jen ty platn√©
        SELECT *
        FROM zpp_api_matrix
          WHERE (lv_where)
          AND datuv <= @p_val
          AND datub >= @p_val
          AND datuv IS NOT INITIAL
          AND datub IS NOT INITIAL
          INTO CORRESPONDING FIELDS OF TABLE @lt_data.


      WHEN r_inval.
        lv_where = |sap_id IN @s_sap_id AND werks IN @s_werks AND api_id IN @s_api_id AND charg IN @s_charg |.

        SELECT *                           " Chci zobrazit jen ty neplatn√©
          FROM zpp_api_matrix
           WHERE (lv_where)
           AND ( datub < @sy-datum
           OR    datuv > @sy-datum
           OR    datuv IS INITIAL
           OR    datub IS INITIAL )
           INTO CORRESPONDING FIELDS OF TABLE @lt_data.
    ENDCASE.

*‚úÖ Naplnƒõn√≠ tabulky s kr√°tk√Ωm textem materi√°lu
    IF lt_data[] IS NOT INITIAL.
      SELECT * FROM makt
       INTO CORRESPONDING FIELDS OF TABLE lt_makt_matnr
       FOR ALL ENTRIES IN lt_data
       WHERE (  matnr = lt_data-sap_id
       OR    matnr = lt_data-api_id )
       AND  ( spras = sy-langu
      OR    spras = 'E' ).
    ENDIF.

* ‚úèÔ∏è naƒç√≠st maktx pro Hotov√Ω v√Ωrovek
    LOOP AT lt_data REFERENCE INTO DATA(lr_data). "

      " Naƒçten√≠ status≈Ø skrze p≈ôehlednost
      IF r_all = 'X'.
        lr_data->verify = COND #( WHEN lr_data->datub >= sy-datum
                           AND lr_data->datuv <= sy-datum
                           AND lr_data->datub > lr_data->datuv
                           AND lr_data->datuv IS NOT INITIAL
                           THEN icon_green_light
                           ELSE icon_red_light ).
      ENDIF.
      DATA(lr_makt_matnr) = REF #( lt_makt_matnr[ matnr = lr_data->sap_id
                                                    spras = sy-langu ] OPTIONAL ).

      IF lr_makt_matnr IS INITIAL.
        lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->sap_id ] OPTIONAL ).
      ENDIF.

      IF lr_makt_matnr IS NOT INITIAL.
        lr_data->maktx = lr_makt_matnr->maktx.
      ELSE.
        lr_data->maktx = space.
      ENDIF.

*‚úèÔ∏è Doplnƒõn√≠ destinace pomoc√≠ splitu a readu
      IF lr_data->maktx IS NOT INITIAL.
        DATA(lv_string) = lr_data->maktx.
        SPLIT lv_string AT '(' INTO TABLE DATA(lt_parts).

        DATA(lv_substring) = lt_parts[ lc_parts_value_2 ].

        SPLIT lv_substring AT ')' INTO TABLE lt_parts.
        lv_substring = lt_parts[ lc_parts_value_1 ].

        lr_data->destination = lv_substring.
      ENDIF.


*‚úèÔ∏è naƒç√≠st maktx pro komponentu komponenty API_NAME
      lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->api_id
                                                    spras = sy-langu ] OPTIONAL ).

      IF lr_makt_matnr IS INITIAL.
        lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data->api_id ] OPTIONAL ).
      ENDIF.

      IF lr_makt_matnr IS NOT INITIAL.
        lr_data->api_name = lr_makt_matnr->maktx.
      ELSE.
        lr_data->api_name = space.
      ENDIF.

      APPEND lr_data->* TO mt_data.

    ENDLOOP.

    " Ulo≈æ√≠m si historick√° data z tabulky
    mt_data_history = mt_data.
  ENDMETHOD.

  METHOD add_row.
    " Definice struktur pro data a pr√°zdn√© ≈ô√°dky üìä
    DATA:
    ls_data      TYPE ty_zpp_api_matrix_str. " Struktura pro data üìù

    APPEND INITIAL LINE TO mt_data.

  ENDMETHOD.

  METHOD save_row.
    DATA  lt_makt_matnr     TYPE TABLE OF makt.  " Tabulka materi√°lov√Ωch ƒç√≠sel

    DATA: lt_selected_rows TYPE lvc_t_row,     " Tabulka vybran√Ωch ≈ô√°dk≈Ø üìë
          lv_selected_rows TYPE i,              " Poƒçet vybran√Ωch ≈ô√°dk≈Ø üßÆ
          lv_index         TYPE i.

    DATA  ls_data_log      TYPE  zpp_api_matrix_l.

    DATA ls_data_final  TYPE          zpp_api_matrix.

    " Struktura pro jeden z√°znam üìÉ

    CONSTANTS: lc_log_delete    TYPE string VALUE 'DELETE',
               lc_log_insert    TYPE string VALUE 'INSERT',
               lc_log_update    TYPE string VALUE 'UPDATE',
               lc_mtart_halb    TYPE mtart  VALUE 'HALB',
               lc_unique_value  VALUE 1      TYPE i,
               lc_parts_value_1 VALUE 1      TYPE i,
               lc_parts_value_2 VALUE 2      TYPE i.

    CLEAR            lt_selected_rows.

    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.


    "Odstranƒõn√≠ oznaƒçen√Ωch ≈ô√°dk≈Ø  p≈ôes SAVE ->Mus√≠m udƒõlat p≈ôed updatem, tyto ≈ô√°dky ji≈æ nep≈Øjde oznaƒçit
    IF mt_data_final[] IS NOT INITIAL.
      "Hled√°m maxim√°ln√≠ hodnotu pro delete
      SELECT MAX( unique_value )
      FROM zpp_api_matrix_l
      INTO @DATA(lv_max_unique_value).

      LOOP AT mt_data_final REFERENCE INTO DATA(lr_data_final)
        WHERE history = 'D'.


        DELETE FROM zpp_api_matrix
     WHERE sap_id = @lr_data_final->sap_id
       AND werks  = @lr_data_final->werks
       AND api_id = @lr_data_final->api_id
       AND charg  = @lr_data_final->charg.



        " Pokud do≈°lo k odstranƒõn√≠, p≈ôid√°m hl√°≈°en√≠ do log≈Ø
        IF sy-subrc = 0.
          lv_max_unique_value = lv_max_unique_value + lc_unique_value.
*
          " Naplnƒõn√≠ struktury pro ZPP_API_MATRIX_L
          MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.
          ls_data_log-datuv_old         = lr_data_final->datuv.
          ls_data_log-datub_old         = lr_data_final->datub.
          ls_data_log-ernam             = sy-uname.
          ls_data_log-change            = lc_log_delete.
          ls_data_log-change_date       = sy-datum.
          ls_data_log-change_time       = sy-uzeit.
          ls_data_log-unique_value      = lv_max_unique_value.

          " Vlo≈æen√≠ dat do logov√© tabulky
          INSERT INTO zpp_api_matrix_l VALUES ls_data_log.
        ENDIF.
      ENDLOOP.

      "Vlo≈æen√≠ mt_data do mtsort_data_final
      INSERT LINES OF mt_data INTO TABLE mt_data_final.
    ELSE.
      mt_data_final = mt_data.
    ENDIF.

    DELETE mt_data_final WHERE history = 'D'.


*    IF lt_selected_rows[] IS NOT INITIAL. "Zat√≠m pou≈æ√≠v√°m , nahradit mt_data_history

    "Hled√°m maxim√°ln√≠ hodnotu pro UPDATE ( Hled√°m po druh√© )
    SELECT MAX( unique_value )
    FROM zpp_api_matrix_l
    INTO @lv_max_unique_value.

    "Vyƒçist√≠m ≈ô√°dky, kde je shoda v histori√≠ dat, nechci s nimi pracovat.
    IF mt_data_final IS NOT INITIAL.
      SORT mt_data_final BY sap_id werks api_id charg maktx DESCENDING.
      DATA(lv_value) = 0.
      LOOP AT mt_data_final REFERENCE INTO lr_data_final.
        lv_value = lv_value + 1.
        lr_data_final->zvalue = lv_value.

        READ TABLE mt_data_history WITH KEY sap_id = lr_data_final->sap_id
                                      werks        = lr_data_final->werks
                                      api_id       = lr_data_final->api_id
                                      charg        = lr_data_final->charg
                                      datuv        = lr_data_final->datuv
                                      datub        = lr_data_final->datub
                                      TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          IF lr_data_final->maktx IS INITIAL.
            CLEAR: lr_data_final->sap_id.
            lr_data_final->status = 'D'.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.

    " Prvn√≠ blok
    IF mt_data_final[] IS NOT INITIAL.

      LOOP AT mt_data_final REFERENCE INTO lr_data_final WHERE sap_id IS NOT INITIAL.

        IF lr_data_final->maktx IS INITIAL.
          lr_data_final->status = 'D'.
        ENDIF.
      ENDLOOP.
    ENDIF.

    " Druh√Ω blok
    IF mt_data_final[] IS NOT INITIAL .
      " Odeb√≠r√°n√≠ D od nejƒçerstvƒõj≈°√≠ho z√°znamu
      SORT mt_data_final BY werks api_id charg zvalue  DESCENDING.
      " Promƒõnn√© pro sledov√°n√≠ posledn√≠ho materi√°lu
      DATA: lv_last_sap_id TYPE matnr,      " SAP materi√°lov√Ω identifik√°tor
            lv_last_werks  TYPE werks_d,    " K√≥d z√°vodu
            lv_last_api_id TYPE idnrk,      " API ID (idnrk)
            lv_last_charg  TYPE charg.      " ƒå√≠slo ≈°ar≈æe


      CLEAR: lv_last_sap_id, lv_last_werks, lv_last_api_id, lv_last_charg.

      LOOP AT mt_data_final REFERENCE INTO lr_data_final WHERE sap_id IS NOT INITIAL.

        " Zkontroluji, zda je maktx pr√°zdn√Ω
        lv_value = sy-tabix.
        lr_data_final->zvalue = lv_value.

        " Pokud je nov√Ω typ materi√°lu, nastav√≠me status na 'D'
        IF lr_data_final->sap_id <> lv_last_sap_id OR
           lr_data_final->werks <> lv_last_werks OR
           lr_data_final->api_id <> lv_last_api_id OR
           lr_data_final->charg <> lv_last_charg.

          " Prvn√≠ materi√°l v nov√© skupinƒõ dostane status ''
          lr_data_final->status = ''.
        ENDIF.


        " Ulo≈æ√≠me si posledn√≠ z√°znam pro porovn√°n√≠ v dal≈°√≠ interaci
        lv_last_sap_id = lr_data_final->sap_id.
        lv_last_werks = lr_data_final->werks.
        lv_last_api_id = lr_data_final->api_id.
        lv_last_charg = lr_data_final->charg.

      ENDLOOP.
    ENDIF.
    " Vr√°t√≠me data do p≈Øvdn√≠ho stavu
    SORT mt_data_final BY sap_id werks api_id charg zvalue DESCENDING.

    LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).  " NAhradit brzy mt_data_history, ƒçistƒõ rorovn√°v√°n√≠m

      lv_index = lr_selected_data->index.

      "READ#
      lr_data_final = REF #( mt_data_final[ lv_index ] OPTIONAL ).

      IF  lr_data_final IS NOT INITIAL  AND lr_data_final->status <> 'D' AND lr_data_final->history <> 'D' AND  lr_data_final->sap_id IS NOT INITIAL.
        "       AND lr_data_final->maktx IS INITIAL.

* Kontrola existence MTART = VPOL v na≈°em p≈ô√≠padƒõ HALB
        IF sy-subrc = 0.

          SELECT SINGLE mtart
            FROM mara
            INTO @DATA(lv_mara)
            WHERE matnr = @lr_data_final->api_id
            AND   mtart = @lc_mtart_halb.         " ‚ùó Zmƒõnit na VPOL u z√°kazn√≠ka

          IF sy-subrc = 0.

            " Beru jen ty data tƒõch materi√°l≈Ø, kter√© chci zobrazit p≈ôi vlo≈æen√≠
            SELECT * FROM makt
             INTO CORRESPONDING FIELDS OF TABLE lt_makt_matnr
             WHERE (  matnr = lr_data_final->sap_id
             OR    matnr = lr_data_final->api_id )
             AND  ( spras = sy-langu
             OR    spras = 'E' ).

            CLEAR ls_data_log.

            " U≈æ si naberu spoleƒçn√° data a budu s nimi pracovat
            MOVE-CORRESPONDING lr_data_final->* TO ls_data_final.
            " P≈ôeƒçtu si historii dat, pozn√°m, zda bylo vlo≈æeno u≈æ nebo ne
            DATA(lr_data_history) = REF #( mt_data_history[ sap_id = lr_data_final->sap_id werks = lr_data_final->werks
                                                            charg  = lr_data_final->charg api_id = lr_data_final->api_id ] OPTIONAL ).


            IF lr_data_history IS NOT INITIAL. " Kontrola, zda nen√≠ u≈æ v datab√°zi z√°znam, pot√© se provede jen update
*                    " probƒõhne update a oprav√≠ nejaktu√°lƒõnƒõj≈°√≠ obdob√≠
              IF lr_data_final->datuv IS NOT INITIAL AND lr_data_final->datub IS NOT INITIAL .

                "PS: M≈Ø≈æe vyskakovac√≠ okno se zobrazit, kter√© uk√°≈æe hodnoty p≈ôed a po a zda chceme updatovat
                UPDATE zpp_api_matrix
                SET datuv = @lr_data_final->datuv,
                datub = @lr_data_final->datub
                WHERE sap_id = @lr_data_final->sap_id
                AND werks  = @lr_data_final->werks
                AND api_id = @lr_data_final->api_id
                AND charg  = @lr_data_final->charg.

                "poƒç√≠t√°n√≠, kolikr√°t probƒõhl loop
                DATA(lv_count) = 0.
                IF sy-subrc = 0.

                  lv_max_unique_value = lv_max_unique_value  + lc_unique_value.

                  MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

                  ls_data_log-ernam             = sy-uname.
                  ls_data_log-change            = lc_log_update.
                  ls_data_log-change_date       = sy-datum.
                  ls_data_log-change_time       = sy-uzeit.
                  ls_data_log-unique_value      = lv_max_unique_value.

                  " Naplnƒõn√≠ log≈Ø
                  INSERT INTO zpp_api_matrix_l VALUES ls_data_log.

                  "Zjistit, kolik m√°me z√°znam≈Ø
                  LOOP AT mt_data_final REFERENCE INTO lr_data_final
                    WHERE sap_id = lr_data_history->sap_id
                    AND werks = lr_data_history->werks
                    AND charg = lr_data_history->charg
                    AND api_id = lr_data_history->api_id.
                    lv_count = lv_count + 1.

                    IF lv_count = 2.
                      EXIT.
                    ENDIF.
                  ENDLOOP.

                  LOOP AT mt_data_history REFERENCE INTO lr_data_history.
                    lr_data_final = REF #( mt_data_final[ sap_id = lr_data_final->sap_id werks = lr_data_final->werks
                                                          charg  = lr_data_final->charg api_id = lr_data_final->api_id ] OPTIONAL ).


                    IF lr_data_final IS NOT INITIAL.
                      DATA(lv_sap_id)           = lr_data_final->sap_id.
                      DATA(lv_werks)            = lr_data_final->werks.
                      DATA(lv_charg)            = lr_data_final->charg.
                      DATA(lv_api_id)           = lr_data_final->api_id.
                      DATA(lv_sap_name)         = lr_data_final->maktx.
                      DATA(lv_destination)      = lr_data_final->destination.
                      DATA(lv_api_name)         = lr_data_final->api_name.
                      DATA(lv_inn_device)       = lr_data_final->inn_device.
                      DATA(lv_production_plant) = lr_data_final->production_plant.
                      DATA(lv_mzp_csp)          = lr_data_final->mzp.
                      DATA(lv_mzp_bc)           = lr_data_final->mzp_csp.
                      DATA(lv_gris_relevation)  = lr_data_final->gris_relevation.

                      "Pokud je 2 a v√≠ce stejn√Ωch z√°znam≈Ø, bude p≈Øvodn√≠ odstranƒõn
                      IF lv_count = 2.
                        lr_data_final->status = 'D'.
                      ENDIF.
                    ENDIF.
                  ENDLOOP.

                  " Hodnoty jsou v≈ædy 2, proto v≈ædy loop
                  LOOP AT mt_data_final REFERENCE INTO lr_data_final
                     WHERE sap_id = lv_sap_id
                     AND werks  = lv_werks
                      AND charg  = lv_charg
                      AND api_id = lv_api_id
                    AND status <> 'D'.

                    IF lr_data_final IS NOT INITIAL.
                      lr_data_final->maktx = lv_sap_name.
                      lr_data_final->destination = lv_destination.
                      lr_data_final->api_name = lv_api_name.
                      lr_data_final->inn_device = lv_inn_device.
                      lr_data_final->production_plant = lv_production_plant.
                      lr_data_final->mzp_csp = lv_mzp_csp.
                      lr_data_final->mzp_bc = lv_mzp_bc..
                      lr_data_final->gris_relevation = lv_gris_relevation.
                    ENDIF.
                  ENDLOOP.
                ENDIF.

              ELSEIF lr_data_final->datuv = '00000000' AND lr_data_final->datub IS NOT INITIAL.
                UPDATE zpp_api_matrix
                SET  datub = @lr_data_final->datub
                  WHERE sap_id = @lr_data_final->sap_id
                  AND werks  = @lr_data_final->werks
                  AND api_id = @lr_data_final->api_id
                  AND charg  = @lr_data_final->charg.

                IF sy-subrc = 0.
                  " Naplnƒõn√≠ log≈Ø
                  lv_max_unique_value = lv_max_unique_value  + lc_unique_value.

                  MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

                  ls_data_log-ernam             = sy-uname.
                  ls_data_log-change            = lc_log_update.
                  ls_data_log-change_date       = sy-datum.
                  ls_data_log-change_time       = sy-uzeit.
                  ls_data_log-unique_value      = lv_max_unique_value.

                  INSERT INTO zpp_api_matrix_l VALUES ls_data_log.

                  "Zjistit, kolik m√°me z√°znam≈Ø
                  LOOP AT mt_data_final REFERENCE INTO lr_data_final
                    WHERE sap_id = lr_data_history->sap_id
                    AND werks = lr_data_history->werks
                    AND charg = lr_data_history->charg
                    AND api_id = lr_data_history->api_id.
                    lv_count = lv_count + 1.

                    IF lv_count = 2.
                      EXIT.
                    ENDIF.
                  ENDLOOP.

                  LOOP AT mt_data_history REFERENCE INTO lr_data_history.
                    lr_data_final = REF #( mt_data_final[ sap_id = lr_data_final->sap_id werks = lr_data_final->werks
                                                          charg  = lr_data_final->charg api_id = lr_data_final->api_id ] OPTIONAL ).


                    IF lr_data_final IS NOT INITIAL.
                      lv_sap_id           = lr_data_final->sap_id.
                      lv_werks            = lr_data_final->werks.
                      lv_charg            = lr_data_final->charg.
                      lv_api_id           = lr_data_final->api_id.
                      DATA(lv_datuv)      = lr_data_final->datuv.
                      lv_sap_name         = lr_data_final->maktx.
                      lv_destination      = lr_data_final->destination.
                      lv_api_name         = lr_data_final->api_name.
                      lv_inn_device       = lr_data_final->inn_device.
                      lv_production_plant = lr_data_final->production_plant.
                      lv_mzp_csp          = lr_data_final->mzp.
                      lv_mzp_bc           = lr_data_final->mzp_csp.
                      lv_gris_relevation  = lr_data_final->gris_relevation.

                      "Pokud je 2 a v√≠ce stejn√Ωch z√°znam≈Ø, bude p≈Øvodn√≠ odstranƒõn
                      IF lv_count = 2.
                        lr_data_final->status = 'D'.
                      ENDIF.
                    ENDIF.
                  ENDLOOP.
                  "P≈ôi≈ôad√≠m si p≈Øvodn√≠ hodnotu data.

                  " Hodnoty jsou v≈ædy 2, proto v≈ædy loop
                  LOOP AT mt_data_final REFERENCE INTO lr_data_final
                     WHERE sap_id = lv_sap_id
                     AND werks  = lv_werks
                      AND charg  = lv_charg
                      AND api_id = lv_api_id
                    AND status <> 'D'.
                    IF lr_data_final IS NOT INITIAL.
                      lr_data_final->datuv = lv_datuv.
                      lr_data_final->maktx = lv_sap_name.
                      lr_data_final->destination = lv_destination.
                      lr_data_final->api_name = lv_api_name.
                      lr_data_final->inn_device = lv_inn_device.
                      lr_data_final->production_plant = lv_production_plant.
                      lr_data_final->mzp_csp = lv_mzp_csp.
                      lr_data_final->mzp_bc = lv_mzp_bc..
                      lr_data_final->gris_relevation = lv_gris_relevation.
                    ENDIF.
                  ENDLOOP.
                ENDIF.

                "M√°me pro p≈ôehled m√≠sto else
              ELSEIF lr_data_final->datuv IS NOT INITIAL AND lr_data_final->datub = '00000000'.
                UPDATE zpp_api_matrix
                SET  datuv = @lr_data_final->datuv
                  WHERE sap_id = @lr_data_final->sap_id
                  AND werks  = @lr_data_final->werks
                  AND api_id = @lr_data_final->api_id
                  AND charg  = @lr_data_final->charg.

                IF sy-subrc = 0.

                  lv_max_unique_value = lv_max_unique_value  + lc_unique_value.

                  MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

                  ls_data_log-ernam             = sy-uname.
                  ls_data_log-change            = lc_log_update.
                  ls_data_log-change_date       = sy-datum.
                  ls_data_log-change_time       = sy-uzeit.
                  ls_data_log-unique_value      = lv_max_unique_value.

                  INSERT INTO zpp_api_matrix_l VALUES ls_data_log.

                  "Zjistit, kolik m√°me z√°znam≈Ø
                  LOOP AT mt_data_final REFERENCE INTO lr_data_final
                    WHERE sap_id = lr_data_history->sap_id
                    AND werks    = lr_data_history->werks
                    AND charg    = lr_data_history->charg
                    AND api_id   = lr_data_history->api_id.
                    lv_count     = lv_count + 1.

                    IF lv_count = 2.
                      EXIT.
                    ENDIF.
                  ENDLOOP.

                  LOOP AT mt_data_history REFERENCE INTO lr_data_history.
                    lr_data_final = REF #( mt_data_final[ sap_id = lr_data_final->sap_id werks = lr_data_final->werks
                                                          charg  = lr_data_final->charg api_id = lr_data_final->api_id ] OPTIONAL ).

                    IF lr_data_final IS NOT INITIAL.
                      lv_sap_id           = lr_data_final->sap_id.
                      lv_werks            = lr_data_final->werks.
                      lv_charg            = lr_data_final->charg.
                      lv_api_id           = lr_data_final->api_id.
                      lv_sap_name         = lr_data_final->maktx.
                      lv_destination      = lr_data_final->destination.
                      lv_api_name         = lr_data_final->api_name.
                      lv_inn_device       = lr_data_final->inn_device.
                      lv_production_plant = lr_data_final->production_plant.
                      lv_mzp_csp          = lr_data_final->mzp.
                      lv_mzp_bc           = lr_data_final->mzp_csp.
                      lv_gris_relevation  = lr_data_final->gris_relevation.

                      DATA(lv_datub)  = lr_data_final->datub.
                      "Pokud je 2 a v√≠ce stejn√Ωch z√°znam≈Ø, bude p≈Øvodn√≠ odstranƒõn
                      IF lv_count = 2.
                        lr_data_final->status = 'D'.
                      ENDIF.
                    ENDIF.
                  ENDLOOP.
                  " Hodnoty jsou v≈ædy 2, proto v≈ædy loop
                  LOOP AT mt_data_final REFERENCE INTO lr_data_final
                     WHERE sap_id = lv_sap_id
                     AND werks  = lv_werks
                      AND charg  = lv_charg
                      AND api_id = lv_api_id
                    AND status <> 'D'.
                    IF lr_data_final IS NOT INITIAL.
                      lr_data_final->datub = lv_datub.
                      lr_data_final->maktx = lv_sap_name.
                      lr_data_final->destination = lv_destination.
                      lr_data_final->api_name = lv_api_name.
                      lr_data_final->inn_device = lv_inn_device.
                      lr_data_final->production_plant = lv_production_plant.
                      lr_data_final->mzp_csp = lv_mzp_csp.
                      lr_data_final->mzp_bc = lv_mzp_bc..
                      lr_data_final->gris_relevation = lv_gris_relevation.
                    ENDIF.
                  ENDLOOP.
                ENDIF.
              ENDIF.

              " ELSEIF z d≈Øvodu ƒçitelnosti k√≥du
              " Insertuji v≈ædy prvn√≠ z√°znam, kter√Ω nem√° v historii odezvu, pot√© insortuji mimo tento IF
            ELSEIF lr_data_final->status <> 'D'. " pokud nen√≠ shoda, jedn√° se o insert. Nesm√≠ m√≠t status delete
              MOVE-CORRESPONDING lr_data_final->* TO ls_data_final.
              INSERT INTO zpp_api_matrix VALUES ls_data_final.
              IF sy-subrc = 0.
                lr_data_final->history = 'I'.
                lv_max_unique_value = lv_max_unique_value  + lc_unique_value.
**‚úèÔ∏è Pokud nem√° mt_data kr√°tk√Ω text materi√°lu k SAP_ID

                DATA(lr_makt_matnr) = REF #( lt_makt_matnr[ matnr = lr_data_final->sap_id spras = sy-langu ] OPTIONAL ).
                IF lr_makt_matnr IS INITIAL.
                  lr_makt_matnr     = REF #( lt_makt_matnr[ matnr = lr_data_final->sap_id  ] OPTIONAL ).
                ENDIF.

                IF lr_makt_matnr IS NOT INITIAL.
                  lr_data_final->maktx = lr_makt_matnr->maktx.
                ELSE.
                  lr_data_final->maktx = space.
                ENDIF.

*‚úèÔ∏è Pokud nem√° mt_data kr√°tk√Ω text materi√°lu k API_ID
                lr_makt_matnr   = REF #( lt_makt_matnr[  matnr = lr_data_final->api_id spras = sy-langu ] OPTIONAL ).

                IF lr_makt_matnr IS INITIAL.
                  lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data_final->api_id ] OPTIONAL ).
                ENDIF.

                IF lr_makt_matnr IS NOT INITIAL.
                  lr_data_final->api_name = lr_makt_matnr->maktx.
                ELSE.
                  lr_data_final->api_name = space.
                ENDIF.

*‚úèÔ∏è Doplnƒõn√≠ destinace pomoc√≠ splitu a readu
                IF lr_data_final->maktx IS NOT INITIAL.

                  DATA(lv_string) = lr_data_final->maktx.
                  SPLIT lv_string AT '(' INTO TABLE DATA(lt_parts).

                  DATA(lv_substring) = lt_parts[ lc_parts_value_2 ].

                  SPLIT lv_substring AT ')' INTO TABLE lt_parts.
                  lv_substring = lt_parts[ lc_parts_value_1 ].

                  lr_data_final->destination = lv_substring.
                ENDIF.

                " Naplnƒõn√≠ struktury pro ZPP_API_MATRIX_L
                MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

                ls_data_log-ernam             = sy-uname.
                ls_data_log-change            = lc_log_insert.
                ls_data_log-change_date       = sy-datum.
                ls_data_log-change_time       = sy-uzeit.
                " Se≈ôad√≠m si tabulku tak, abych na≈°el nejvy≈°≈°√≠ hodnotu unik√°tn√≠ hodnoty.

                ls_data_log-unique_value      = lv_max_unique_value.

                " Vlo≈æen√≠ dat do logov√© tabulky
                INSERT INTO zpp_api_matrix_l VALUES ls_data_log.
              ENDIF.
            ENDIF.
          ELSE.
            MESSAGE |≈ò√°dek ƒç√≠slo { lv_index } nebyl ulo≈æen do datab√°ze.|  TYPE 'I'.
          ENDIF.

        ELSE.
          " Insertuje druhou a dal≈°√≠ hodnotu, kter√° nem√° odezvu v mt_data_history
          MOVE-CORRESPONDING lr_data_final->* TO ls_data_final.
          INSERT INTO zpp_api_matrix VALUES ls_data_final.
          IF sy-subrc = 0.
            lr_data_final->history = 'I'.
            lv_max_unique_value    = lv_max_unique_value  + lc_unique_value.
**‚úèÔ∏è Pokud nem√° mt_data kr√°tk√Ω text materi√°lu k SAP_ID

            lr_makt_matnr      = REF #( lt_makt_matnr[ matnr = lr_data_final->sap_id spras = sy-langu ] OPTIONAL ).
            IF lr_makt_matnr IS INITIAL.
              lr_makt_matnr    = REF #( lt_makt_matnr[ matnr = lr_data_final->sap_id  ] OPTIONAL ).
            ENDIF.

            IF lr_makt_matnr IS NOT INITIAL.
              lr_data_final->maktx = lr_makt_matnr->maktx.
            ELSE.
              lr_data_final->maktx = space.
            ENDIF.

*‚úèÔ∏è Pokud nem√° mt_data kr√°tk√Ω text materi√°lu k API_ID
            lr_makt_matnr   = REF #( lt_makt_matnr[  matnr = lr_data_final->api_id spras = sy-langu ] OPTIONAL ).

            IF lr_makt_matnr IS INITIAL.
              lr_makt_matnr = REF #( lt_makt_matnr[ matnr = lr_data_final->api_id ] OPTIONAL ).
            ENDIF.

            IF lr_makt_matnr IS NOT INITIAL.
              lr_data_final->api_name = lr_makt_matnr->maktx.
            ELSE.
              lr_data_final->api_name = space.
            ENDIF.

*‚úèÔ∏è Doplnƒõn√≠ destinace pomoc√≠ splitu a readu
            IF lr_data_final->maktx IS NOT INITIAL.

              lv_string = lr_data_final->maktx.
              SPLIT lv_string AT '(' INTO TABLE lt_parts.

              lv_substring = lt_parts[ lc_parts_value_2 ].

              SPLIT lv_substring AT ')' INTO TABLE lt_parts.
              lv_substring = lt_parts[ lc_parts_value_1 ].

              lr_data_final->destination = lv_substring.
            ENDIF.

            " Naplnƒõn√≠ struktury pro ZPP_API_MATRIX_L
            MOVE-CORRESPONDING lr_data_final->* TO ls_data_log.

            ls_data_log-ernam             = sy-uname.
            ls_data_log-change            = lc_log_insert.
            ls_data_log-change_date       = sy-datum.
            ls_data_log-change_time       = sy-uzeit.
            " Se≈ôad√≠m si tabulku tak, abych na≈°el nejvy≈°≈°√≠ hodnotu unik√°tn√≠ hodnoty.

            ls_data_log-unique_value      = lv_max_unique_value.

            " Vlo≈æen√≠ dat do logov√© tabulky
            INSERT INTO zpp_api_matrix_l VALUES ls_data_log.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF mt_data[] IS NOT INITIAL.
      " Na konci chci zobrzait v√Ωsledky do ALV
      mt_data = mt_data_final.
      " Udƒõl√°m clear. Pokud nƒõkdo oznaƒç√≠ v≈°echny ≈ô√°dky nƒõkolikr√°t po sobƒõ a p≈ôid√° do datab√°ze, budou duplicitn√≠ ≈ô√°dky
      CLEAR mt_data_final[].
      MESSAGE |Data byla do datab√°ze √∫spƒõ≈°nƒõ ulo≈æena.|  TYPE 'I'.
    ELSE.
      mt_data = mt_data_final.
      CLEAR mt_data_final[].
      MESSAGE |Data nebyla do datab√°ze √∫spƒõ≈°nƒõ ulo≈æena.|  TYPE 'I'.
    ENDIF.

    " Aktualizace historick√Ωch dat
    mt_data_history = mt_data.
    CLEAR gv_changed.
  ENDMETHOD.


  METHOD delete.

    DATA: ls_data_final TYPE ty_zpp_api_matrix_str.

    DATA:
      lt_selected_rows  TYPE lvc_t_row,
      lv_selected_rows  TYPE i,
      lv_index          TYPE i,
      ls_data_log       TYPE zpp_api_matrix_l,
      lt_zpp_api_matrix TYPE TABLE OF zpp_api_matrix.

    CONSTANTS: lc_log_delete   TYPE char40 VALUE 'DELETE_DATA',
               lc_index_1      TYPE i VALUE 1,
               lc_unique_value TYPE i VALUE 1.

    CLEAR lt_selected_rows.


    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.

    IF lt_selected_rows[] IS NOT INITIAL.

      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
        lv_index = lr_selected_data->index.

        " Pot≈ôebuji z√≠skat data, ≈æe do≈°lo ke smaz√°n√≠ ≈ô√°dku a z√°rove≈à k jeho smaz√°n√≠ v ALV
        DATA(lr_data) = REF #( mt_data[ lv_index ] ).
        lr_data->history = 'D'.
        MOVE-CORRESPONDING lr_data->* TO ls_data_final.
        APPEND ls_data_final TO mt_data_final.
        CLEAR lr_data->sap_id.

      ENDLOOP.
      "Smaz√°n√≠ z ALV
      DELETE mt_data WHERE sap_id IS INITIAL.
      mt_data_history = mt_data.
*      DELETE mt_data WHERE maktx  IS INITIAL.
    ELSE.
      MESSAGE |Oznaƒçte ≈ô√°dky, kter√© maj√≠ b√Ωt odstranƒõny z datab√°ze.|  TYPE 'I'.
    ENDIF.
  ENDMETHOD.

  METHOD display.
    CALL SCREEN 0100.
  ENDMETHOD.

  METHOD alv_create.

    DATA: lt_fcat     TYPE        lvc_t_fcat,
          ls_fcat     TYPE        lvc_s_fcat,
          ls_layout   TYPE        lvc_s_layo,
          lr_fieldcat TYPE REF TO lvc_s_fcat,
          ls_exclude  TYPE        ui_func,
          gt_exclude  TYPE        ui_functions.

    DATA: ls_stylerow TYPE        lvc_s_styl,             " Styl pro ≈ô√°dek v ALV
          lr_listrow  TYPE REF TO ty_zpp_api_matrix_str.  " Reference na strukturu typu ty_zpp_api_matrix_str

    " üìå Vytvo≈ôen√≠ kontejneru s n√°zvem ALV_GRID
    IF mo_custom_container IS INITIAL.
      CREATE OBJECT mo_custom_container
        EXPORTING
          container_name = 'ALV_GRID'.
      CREATE OBJECT mo_grid
        EXPORTING
          i_parent = mo_custom_container.

      " üìå Zalo≈æen√≠ fieldcatalogu pro zobrazen√≠ ALV
      CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
        EXPORTING
          i_structure_name       = 'ZPP_API_MATRIX_STR'   " Struktura pro ALV
        CHANGING
          ct_fieldcat            = lt_fcat
        EXCEPTIONS
          inconsistent_interface = 1
          program_error          = 2
          OTHERS                 = 3.

*‚úèÔ∏è Zaji≈°tƒõn√≠ editovatelnosti pr√°zdn√Ωch ≈ô√°dk≈Ø
      LOOP AT mt_data REFERENCE INTO lr_listrow.
        CLEAR lr_listrow->cellstyles.

        " Podm√≠nka pro zobrazen√≠ editace
        lr_listrow->cellstyles = COND #(
    WHEN (    lr_listrow->sap_id IS NOT INITIAL OR lr_listrow->werks IS NOT INITIAL
         OR   lr_listrow->api_id IS NOT INITIAL OR lr_listrow->charg IS NOT INITIAL )
         AND   lr_listrow->status = ''
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )
    WHEN ( lr_listrow->sap_id IS INITIAL AND lr_listrow->werks IS INITIAL
         AND   lr_listrow->api_id IS INITIAL AND lr_listrow->charg IS INITIAL )
         AND   lr_listrow->status = ''
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )


    ELSE lr_listrow->cellstyles ).

      ENDLOOP.

      LOOP AT lt_fcat REFERENCE INTO lr_fieldcat.
        "  üìå Umo≈ænit editaci pro DATUV a DATUB a p≈ôejmenov√°n√≠ sloupc≈Ø.
        CASE lr_fieldcat->fieldname.
          WHEN 'SAP_ID'.

            lr_fieldcat->coltext = 'SAP_ID'.            " Zmƒõna n√°zvu sloupce SAP_ID
            lr_fieldcat->key = 'X'.
            lr_fieldcat->edit = 'X'.
          WHEN 'WERKS'.
            lr_fieldcat->coltext = 'Z√°vod'.             " Zmƒõna n√°zvu sloupce WERKS
            lr_fieldcat->key = 'X'.
            lr_fieldcat->edit = 'X'.
          WHEN 'MAKTX'.
            lr_fieldcat->coltext = 'N√°zev'.             " Zmƒõna n√°zvu sloupce MAKTX
*            lr_fieldcat->edit = 'X'.
          WHEN 'DESTINATION'.
            lr_fieldcat->coltext = 'Destinace'.         " Zmƒõna n√°zvu sloupce DESTINATION
*            lr_fieldcat->edit = 'X'.
          WHEN 'INN_DEVICE'.
            lr_fieldcat->coltext = 'INN za≈ôazen√≠'.       " Zmƒõna n√°zvu sloupce INN_DEVICE
*            lr_fieldcat->edit = 'X'.
          WHEN 'MZP'.
            lr_fieldcat->coltext = 'MZP'.               " Zmƒõna n√°zvu sloupce MZP
*            lr_fieldcat->edit = 'X'.
          WHEN 'CHARG'.
            lr_fieldcat->coltext = '≈†ar≈æe'.    " Zmƒõna n√°zvu sloupce CHARG
            lr_fieldcat->key = 'X'.
            lr_fieldcat->edit = 'X'.
          WHEN 'PRODUCTION_PLANT'.
            lr_fieldcat->coltext = 'M√≠sto v√Ωrovy'.      " Zmƒõna n√°zvu sloupce PRODUCTION_PLANT
*            lr_fieldcat->edit = 'X'.
          WHEN 'MZP_CSP'.
            lr_fieldcat->coltext = 'MZP ƒåSP'.           " Zmƒõna n√°zvu sloupce MZP_CSP
*            lr_fieldcat->edit = 'X'.
          WHEN 'API_ID'.
            lr_fieldcat->edit = 'X'.
            lr_fieldcat->coltext = 'API ID'.            " Zmƒõna n√°zvu sloupce API_ID
            lr_fieldcat->key = 'X'.
          WHEN 'API_NAME'.
            lr_fieldcat->coltext = 'API n√°zev'.         " Zmƒõna n√°zvu sloupce API_NAME
*            lr_fieldcat->edit = 'X'.
          WHEN 'MZP_BC'.
            lr_fieldcat->coltext = 'MZP BC'.            " Zmƒõna n√°zvu sloupce MZP_BC
*            lr_fieldcat->edit = 'X'.
          WHEN 'DATUV'.
            lr_fieldcat->coltext = 'Platnost od'.       " Zmƒõna n√°zvu sloupce DATUV
            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
          WHEN 'DATUV_OLD'.
            lr_fieldcat->coltext = 'Platnost od(OLD)'.  " Zmƒõna n√°zvu sloupce DATUV_OLD
*            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'DATUB'.
            lr_fieldcat->coltext = 'Platnost do'.       " Zmƒõna n√°zvu sloupce DATUB
            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
          WHEN 'DATUB_OLD'.
            lr_fieldcat->coltext = 'Platnost do(OLD)'.       " Zmƒõna n√°zvu sloupce DATUB
*            lr_fieldcat->edit = 'X'.
            lr_fieldcat->key = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'GRIS_RELEVATION'.
            lr_fieldcat->coltext = 'GRIS relevance'.    " Zmƒõna n√°zvu sloupce GRIS_RELEVATION
*            lr_fieldcat->edit = 'X'.
          WHEN 'VERIFY'.
            lr_fieldcat->coltext = 'Platnost'.          " Zmƒõna n√°zvu sloupce VERIFY
            IF r_all <> 'X'.
              lr_fieldcat->no_out = 'X'.
              lr_fieldcat->tech = 'X'.
            ENDIF.
*            lr_fieldcat->edit = 'X'.
          WHEN 'STATUS'.
            lr_fieldcat->no_out = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'UNIQUE_VALUE'.
            lr_fieldcat->no_out = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN  'HISTORY'.
            lr_fieldcat->no_out = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'ZINDEX'.
            lr_fieldcat->no_out = 'X'.
            lr_fieldcat->tech = 'X'.
          WHEN 'ZVALUE'.
            lr_fieldcat->no_out = 'X'.
            lr_fieldcat->tech = 'X'.

        ENDCASE.
      ENDLOOP.

      DELETE lt_fcat WHERE fieldname IS INITIAL.
      ls_exclude = cl_gui_alv_grid=>mc_fc_views.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_info.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_print.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_check.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
      APPEND ls_exclude TO gt_exclude.

      ls_layout-stylefname = 'CELLSTYLES'.
      ls_layout-sel_mode   = 'A'.
      ls_layout-zebra      = 'X'.
      ls_layout-cwidth_opt = 'X'.
      gs_variant-report    = sy-repid.
      gs_variant-username  = sy-uname.

      " üìå Zobrazen√≠ modul√°rn√≠ tabulky do ALV
      CALL METHOD mo_grid->set_table_for_first_display
        EXPORTING
          is_variant                    = gs_variant
          is_layout                     = ls_layout
          i_save                        = 'A'
          it_toolbar_excluding          = gt_exclude
        CHANGING
          it_fieldcatalog               = lt_fcat
          it_outtab                     = mt_data
        EXCEPTIONS
          invalid_parameter_combination = 1
          program_error                 = 2
          too_many_lines                = 3
          OTHERS                        = 4.

      IF sy-subrc EQ 0.

        SET HANDLER handle_toolbar                        FOR mo_grid.
        SET HANDLER handle_double_click                   FOR mo_grid.
        SET HANDLER handle_user_command                   FOR mo_grid.
        SET HANDLER handle_data_changed                   FOR mo_grid.

        CALL METHOD mo_grid->set_toolbar_interactive.

        CALL METHOD mo_grid->register_edit_event
          EXPORTING
            i_event_id = cl_gui_alv_grid=>mc_evt_enter.

        CALL METHOD mo_grid->set_focus
          EXPORTING
            control = mo_grid.
      ENDIF.
    ELSE.
      alv_refresh( ).
    ENDIF.
  ENDMETHOD.

  METHOD alv_refresh.

    DATA  ls_stable   TYPE lvc_s_stbl.

    "Naplnƒõn√≠ historick√Ωch dat do tabulky

    ls_stable-row = 'X'.
    ls_stable-col = 'X'.

    CALL METHOD mo_grid->refresh_table_display
      EXPORTING
        is_stable = ls_stable.
  ENDMETHOD.

  METHOD alv_refresh_popup.

    DATA  ls_stable   TYPE lvc_s_stbl.

    "Naplnƒõn√≠ historick√Ωch dat do tabulky

    ls_stable-row = 'X'.
    ls_stable-col = 'X'.

    CALL METHOD mo_grid_popup->refresh_table_display
      EXPORTING
        is_stable = ls_stable.
  ENDMETHOD.

  METHOD alv_edit.

    DATA:

      lt_selected_rows TYPE lvc_t_row,
      lv_index         TYPE i.

    DATA: ls_stylerow TYPE        lvc_s_styl,             " Styl pro ≈ô√°dek v ALV
          lr_listrow  TYPE REF TO ty_zpp_api_matrix_str.  " Reference na strukturu typu ty_zpp_api_matrix_str


    CLEAR lt_selected_rows.

    " Pro jistotu vyma≈æeme v≈°echny ≈ô√°dky se znaky v√Ωmazu

    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.

*‚úèÔ∏è Zaji≈°tƒõn√≠ editovatelnosti pr√°zdn√Ωch ≈ô√°dk≈Ø
    IF lt_selected_rows[] IS NOT INITIAL.
      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_data).
        lv_index = lr_selected_data->index.

        lr_listrow = REF #( mt_data[ lv_index ] ).

        " Podm√≠nka pro zobrazen√≠ editace
        lr_listrow->cellstyles = COND #(
    WHEN (    lr_listrow->sap_id IS INITIAL OR lr_listrow->werks IS INITIAL
         OR   lr_listrow->api_id IS INITIAL OR lr_listrow->charg IS INITIAL )
         AND   lr_listrow->status = ''
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )
    WHEN lr_listrow->sap_id IS NOT INITIAL
         AND lr_listrow->werks IS NOT INITIAL
         AND lr_listrow->api_id IS NOT INITIAL
         AND lr_listrow->charg IS NOT INITIAL
         AND lr_listrow->status = 'X'
    THEN VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_enabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
    )

    ELSE    VALUE #(
        ( fieldname = 'SAP_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'WERKS'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'CHARG'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_ID'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'API_NAME'          style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MAKTX'             style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DESTINATION'       style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'INN_DEVICE'        style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP'               style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'PRODUCTION_PLANT'  style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_CSP'           style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'MZP_BC'            style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUV_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'DATUB_OLD'         style = cl_gui_alv_grid=>mc_style_disabled )
        ( fieldname = 'VERIFY'            style = cl_gui_alv_grid=>mc_style_disabled )
      ) ).

*‚úèÔ∏è Zji≈°en√≠ platnosti certifik√°tu
        IF r_all = 'X'.
          lr_listrow->verify = COND #( WHEN lr_listrow->datub >= sy-datum
                                       AND lr_listrow->datuv  <= sy-datum
                                       AND lr_listrow->datub  > lr_listrow->datuv
                                       AND lr_listrow->datuv IS NOT INITIAL
                                       THEN icon_green_light
                                       ELSE icon_red_light ).
        ENDIF.
      ENDLOOP.
    ENDIF.

    DELETE mt_data WHERE status = 'D'.
*    DELETE mt_data WHERE history = 'D'.
  ENDMETHOD.

  METHOD handle_data_changed.

    DATA: lt_error  TYPE TABLE OF lvc_s_modi, " Tabulka pro chyby
          ls_modi   TYPE lvc_s_modi,          " Struktura pro jeden z√°znam o zmƒõnƒõ
          ls_error  TYPE lvc_s_modi,          " Struktura pro chybu
          lv_sap_id TYPE matnr,               " SAP ID pro materi√°l
          lv_werks  TYPE werks_d,             " K√≥d z√°vodu
          lv_api_id TYPE idnrk,               " API ID pro identifikaci
          lv_charg  TYPE charg_d,             " ƒå√≠slo ≈°ar≈æe
          lv_datuv  TYPE datuv,
          lv_datub  TYPE datub,
          lv_length TYPE i.                   " D√©lka promƒõnn√©

    CONSTANTS lc_halb TYPE mtart VALUE 'HALB'.

    IF mt_data_history[] <> mt_data.
      gv_changed = 'X'.
    ELSE.
      gv_changed = 'X'.
    ENDIF.

    " Poƒçet ≈ô√°dk≈Ø v mt_data
    DATA(lv_lines_data) = lines( mt_data ).

    " Zji≈°tƒõn√≠ poƒçtu ≈ô√°dk≈Ø v z√°znamu
    LOOP AT er_data_changed->mt_good_cells INTO ls_modi.
      IF ls_modi-row_id > lv_lines_data.
        DATA(lv_max_value) = ls_modi-row_id.
      ENDIF.
    ENDLOOP.

    " Vypoƒç√≠t√°n√≠, kolik ≈ô√°dk≈Ø se mus√≠ p≈ôidat do mt_data.

    IF lv_max_value IS NOT INITIAL.
      DATA(lv_final_lines) = lv_max_value - lv_lines_data.
      DO lv_final_lines TIMES.
        APPEND INITIAL LINE TO mt_data.
      ENDDO.
    ENDIF.

    LOOP AT er_data_changed->mt_good_cells INTO ls_modi.
      " Ovƒõ≈ô√≠me, zda se zmƒõnila hodnota z√°vodu (SAP_ID)
      CASE ls_modi-fieldname.

        WHEN 'SAP_ID'.
          lv_sap_id = ls_modi-value.
          SELECT SINGLE matnr
            FROM mara
            INTO @DATA(lv_mara)
          WHERE matnr = @lv_sap_id.

          IF sy-subrc <> 0.
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.
            APPEND ls_error TO mt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = |Neplatn√© SAP_ID na ≈ô√°dku: { sy-tabix } |
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.

              " Ma≈æu v√Ωhradnƒõ prvn√≠ ≈ô√°dek tabulky, proto bez []
              CLEAR: lt_error, ls_error.

              " Chybn√° hodnota => p≈ôid√°me do seznamu chyb
            ENDIF.
          ENDIF.



          " Ovƒõ≈ô√≠me, zda se zmƒõnila hodnota z√°vodu (WERKS)
        WHEN 'WERKS'.
          lv_werks = ls_modi-value.

          " Zkontrolujeme, zda z√°vod existuje v tabulce T001W
          SELECT SINGLE werks
            FROM t001w
            INTO @DATA(lv_dummy)
          WHERE werks = @lv_werks.
          IF sy-subrc <> 0.

            " Chybn√° hodnota => p≈ôid√°me do seznamu chyb
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.
            APPEND ls_error TO mt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = 'Neplatn√Ω z√°vod'
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.

              CLEAR: lt_error, ls_error.
            ENDIF.
          ENDIF.

        WHEN 'CHARG'.

          lv_length = 10.
          lv_charg = ls_modi-value.

          IF strlen( lv_charg ) <> lv_length.

            " Chybn√° hodnota => p≈ôid√°me do seznamu chyb
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.
            APPEND ls_error TO mt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = 'Neplatn√© CHARG'
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.
              CLEAR: lt_error, ls_error.
            ENDIF.
          ENDIF.

        WHEN 'API_ID'.
          lv_api_id = ls_modi-value.
          SELECT SINGLE matnr
            FROM mara
            INTO @lv_mara
          WHERE matnr = @lv_api_id.

          IF sy-subrc <> 0.
            " Chybn√° hodnota => p≈ôid√°me do seznamu chyb
            ls_error = ls_modi.
            APPEND ls_error TO lt_error.
            APPEND ls_error TO mt_error.

            IF lt_error IS NOT INITIAL.
              LOOP AT lt_error INTO ls_modi.
                CALL METHOD er_data_changed->add_protocol_entry
                  EXPORTING
                    i_msgid     = 'ZMSG'
                    i_msgty     = 'E'
                    i_msgno     = '001'
                    i_msgv1     = 'Neplatn√© API_ID'
                    i_fieldname = ls_modi-fieldname
                    i_row_id    = ls_modi-row_id.

              ENDLOOP.
              CLEAR: lt_error, ls_error.
            ENDIF.
          ELSE.
            " Pokud je z√°znam v MATNR, ale nen√≠ HALB(VPOL u z√°kazn√≠ka)
            SELECT SINGLE matnr
              FROM mara
              INTO @lv_mara
              WHERE matnr = @lv_api_id
            AND   mtart = @lc_halb.

            IF sy-subrc <> 0.
              ls_error = ls_modi.
              APPEND ls_error TO lt_error.
              APPEND ls_error TO mt_error.

              IF lt_error IS NOT INITIAL.
                LOOP AT lt_error INTO ls_modi.
                  CALL METHOD er_data_changed->add_protocol_entry
                    EXPORTING
                      i_msgid     = 'ZMSG'
                      i_msgty     = 'E'
                      i_msgno     = '001'
                      i_msgv1     = 'SAP_ID nen√≠ typ materi√°lu HALB.'
                      i_fieldname = ls_modi-fieldname
                      i_row_id    = ls_modi-row_id.

                ENDLOOP.

                CLEAR: lt_error, ls_error.
              ENDIF.
            ENDIF.
          ENDIF.
*          ENDIF.

        WHEN 'DATUV'. "
          lv_datuv = ls_modi-value.
        WHEN 'DATUB'.
          lv_datub = ls_modi-value.

          " Kontrola, zda DATUV a DATUB jsou platn√°, reaguje jen tehdy, pokud jsou vyplnƒõny obƒõ data
          IF lv_datuv IS NOT INITIAL AND lv_datub IS NOT INITIAL AND lv_datuv > lv_datub.

            ls_error = ls_modi.
            ls_error-fieldname = 'DATUB'.
            APPEND ls_error TO lt_error.
            APPEND ls_error TO mt_error.

            LOOP AT lt_error INTO ls_modi.
              CALL METHOD er_data_changed->add_protocol_entry
                EXPORTING
                  i_msgid     = 'ZMSG'
                  i_msgty     = 'E'
                  i_msgno     = '001'
                  i_msgv1     = |Data certifik√°tu nejsou platn√°: { ls_modi-fieldname }|
                  i_fieldname = ls_modi-fieldname
                  i_row_id    = ls_modi-row_id.
            ENDLOOP.

          ENDIF.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.

  METHOD read_popup.

    DATA: lt_selected_rows TYPE lvc_t_row,
          lv_selected_rows TYPE i,
          lv_index         TYPE i.

    DATA: lt_log        TYPE TABLE OF zpp_api_matrix_l,
          lt_data_popup TYPE TABLE OF zpp_api_matrix_l,
          ls_data_popup TYPE          zpp_api_matrix_l.

    CLEAR lt_selected_rows.

    CALL METHOD mo_grid->get_selected_rows
      IMPORTING
        et_index_rows = lt_selected_rows.

    IF lt_selected_rows[] IS NOT INITIAL.

      "Vyƒçist√≠m, kdyby nesla tabulka data
      CLEAR mt_data_popup[].

      " Proch√°z√≠m jen oznaƒçen√© ≈ô√°dky
      LOOP AT lt_selected_rows REFERENCE INTO DATA(lr_selected_rows).
        lv_index = lr_selected_rows->index.

        DATA(lr_data) = REF #( mt_data[ lv_index ] OPTIONAL ).
        IF lr_data IS NOT INITIAL.
          MOVE-CORRESPONDING lr_data->* TO ls_data_popup.
          APPEND ls_data_popup TO lt_data_popup.
        ENDIF.

      ENDLOOP.

      " Z√≠sk√°m jen ta data, kter√° jsem oznaƒçil
      IF lt_data_popup IS NOT INITIAL.
        SELECT *
          FROM zpp_api_matrix_l
          INTO TABLE mt_data_popup
          FOR ALL ENTRIES IN lt_data_popup
          WHERE sap_id = lt_data_popup-sap_id
          AND   werks  = lt_data_popup-werks
          AND   charg  = lt_data_popup-charg
          AND   api_id = lt_data_popup-api_id.
      ENDIF.

      " Pokud tabulka nebyla naplnƒõna daty
      IF mt_data_popup IS INITIAL.
        MESSAGE |Nebyly nalezeny ≈æ√°dn√© z√°znamy z historie log≈Ø.|  TYPE 'I'.
      ELSE.
        "Chceme vytvo≈ôit ALV jen tehdy, kdy≈æ m√°me nƒõjak√© z√°znamy.
        alv_create_popup( ).
      ENDIF.
    ELSE.
      MESSAGE |Oznaƒçte ≈ô√°dky, kde m√° b√Ωt zobrazena historie log≈Ø.|  TYPE 'I'.
      " Vyƒçist√≠me tabulku, aby nenesla ≈æ√°dn√° ne≈æ√°douc√≠ data
      CLEAR mt_data_popup[].
    ENDIF.

  ENDMETHOD.

  METHOD display_popup.
    CALL SCREEN 0200.
  ENDMETHOD.

  METHOD alv_create_popup.

    DATA: lt_fcat     TYPE        lvc_t_fcat,
          ls_fcat     TYPE        lvc_s_fcat,
          ls_layout   TYPE        lvc_s_layo,
          lr_fieldcat TYPE REF TO lvc_s_fcat,
          ls_exclude  TYPE        ui_func,
          gt_exclude  TYPE        ui_functions.

    DATA: ls_stylerow TYPE        lvc_s_styl.             " Styl pro ≈ô√°dek v ALV


    " üìå Vytvo≈ôen√≠ kontejneru s n√°zvem ALV_GRID
    IF mo_custom_container_popup IS INITIAL.
      CREATE OBJECT mo_custom_container_popup
        EXPORTING
          container_name = 'ALV_GRID_POPUP'.
      CREATE OBJECT mo_grid_popup
        EXPORTING
          i_parent = mo_custom_container_popup.

      " üìå Zalo≈æen√≠ fieldcatalogu pro zobrazen√≠ ALV
      CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
        EXPORTING
          i_structure_name       = 'ZPP_API_MATRIX_L'   " Struktura pro ALV
        CHANGING
          ct_fieldcat            = lt_fcat
        EXCEPTIONS
          inconsistent_interface = 1
          program_error          = 2
          OTHERS                 = 3.


      LOOP AT lt_fcat REFERENCE INTO lr_fieldcat.
        "  üìå Umo≈ænit editaci pro DATUV a DATUB a p≈ôejmenov√°n√≠ sloupc≈Ø.
        CASE lr_fieldcat->fieldname.
          WHEN 'SAP_ID'.
            lr_fieldcat->coltext = 'SAP_ID'.            " Zmƒõna n√°zvu sloupce SAP_ID
            lr_fieldcat->edit = ''.
          WHEN 'WERKS'.
            lr_fieldcat->coltext = 'Z√°vod'.             " Zmƒõna n√°zvu sloupce WERKS
            lr_fieldcat->edit = ''.
          WHEN 'CHARG'.
            lr_fieldcat->coltext = '≈†ar≈æe'.    " Zmƒõna n√°zvu sloupce CHARG
            lr_fieldcat->edit = ''.
          WHEN 'API_ID'.
            lr_fieldcat->edit = ''.
            lr_fieldcat->coltext = 'API ID'.            " Zmƒõna n√°zvu sloupce API_ID
          WHEN 'UNIQUE_VALUE'.
            lr_fieldcat->edit = ''.
            lr_fieldcat->coltext = 'Unik√°tn√≠ hodnota'.
          WHEN 'DATUV'.
            lr_fieldcat->coltext = 'Platnost od'.       " Zmƒõna n√°zvu sloupce DATUV
            lr_fieldcat->edit = ''.
          WHEN 'DATUV_OLD'.
            lr_fieldcat->coltext = 'Platnost od(OLD)'.  " Zmƒõna n√°zvu sloupce DATUV_OLD
            lr_fieldcat->edit = ''.
          WHEN 'DATUB'.
            lr_fieldcat->coltext = 'Platnost do'.       " Zmƒõna n√°zvu sloupce DATUB
            lr_fieldcat->edit = ''.
          WHEN 'DATUB_OLD'.
            lr_fieldcat->coltext = 'Platnost do(OLD)'.       " Zmƒõna n√°zvu sloupce DATUB
          WHEN 'ERNAM'.
            lr_fieldcat->edit = ''.
            lr_fieldcat->coltext = 'Zmƒõnil'.
          WHEN 'CHANGE'.
            lr_fieldcat->edit = ''.
            lr_fieldcat->coltext = 'Zmƒõna'.
          WHEN 'CHANGE_DATE'.
            lr_fieldcat->edit = ''.
            lr_fieldcat->coltext = 'Datum zmƒõny'.
          WHEN 'CHANGE_TIME'.
            lr_fieldcat->edit = ''.
            lr_fieldcat->coltext = 'ƒåas zmƒõny'.
        ENDCASE.
      ENDLOOP.

      DELETE lt_fcat WHERE fieldname IS INITIAL.
      ls_exclude = cl_gui_alv_grid=>mc_fc_views.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_info.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_print.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_check.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
      APPEND ls_exclude TO gt_exclude.
      ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
      APPEND ls_exclude TO gt_exclude.

      ls_layout-stylefname = 'CELLSTYLES'.
      ls_layout-sel_mode   = 'A'.
      ls_layout-zebra      = 'X'.
      ls_layout-cwidth_opt = 'X'.
      gs_variant-report    = sy-repid.
      gs_variant-username  = sy-uname.

      " üìå Zobrazen√≠ modul√°rn√≠ tabulky do ALV
      CALL METHOD mo_grid_popup->set_table_for_first_display
        EXPORTING
          is_variant                    = gs_variant
          is_layout                     = ls_layout
          i_save                        = 'A'
          it_toolbar_excluding          = gt_exclude
        CHANGING
          it_fieldcatalog               = lt_fcat
          it_outtab                     = mt_data_popup
        EXCEPTIONS
          invalid_parameter_combination = 1
          program_error                 = 2
          too_many_lines                = 3
          OTHERS                        = 4.

      IF sy-subrc EQ 0.

      ENDIF.
    ELSE.
      alv_refresh_popup( ).
    ENDIF.
  ENDMETHOD.

  METHOD handle_toolbar.

    DATA lr_toolbar TYPE REF TO stb_button.

    " Vytvo≈ôen√≠ nov√©ho bloku pamƒõti pomoc√≠ NEW stb_button( ).
    " Vyhnu se t√≠m clearu, alokuji si pro ka≈æd√© new novou instanci
    lr_toolbar = NEW stb_button( ).
    lr_toolbar->butn_type = 3.
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    " Alokace pamƒõti pro dal≈°√≠ tlaƒç√≠tka
    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'ADD_ROW'.
    lr_toolbar->icon      = icon_create.
    lr_toolbar->quickinfo = 'P≈ôidat ≈ô√°dek'(000).
    lr_toolbar->text      = 'P≈ôidat ≈ô√°dek'(000).
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'SAVE'.
    lr_toolbar->icon      = icon_create.
    lr_toolbar->quickinfo = 'Ulo≈æit do datab√°ze005'(005).
    lr_toolbar->text      = 'Ulo≈æit do datab√°ze005'(005).
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'DELETE'.
    lr_toolbar->icon      = icon_delete.
    lr_toolbar->quickinfo = 'Odebrat z√°znam'(003).
    lr_toolbar->text      = 'Odebrat z√°znam'(003).
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

    lr_toolbar = NEW stb_button( ).
    lr_toolbar->function  = 'HISTORY'.
    lr_toolbar->icon      = icon_alarm.
    lr_toolbar->quickinfo = 'Zobrazit historii oznaƒçen√Ωch ≈ô√°dk≈Ø:'(004).
    lr_toolbar->text      = 'Zobrazit historii oznaƒçen√Ωch ≈ô√°dk≈Ø:'(004).
    APPEND lr_toolbar->* TO e_object->mt_toolbar.

  ENDMETHOD.

  METHOD handle_double_click.

    DATA(lr_data) = REF #( mt_data[ e_row ] OPTIONAL ).
    " Zbyteƒçn√©, ale m√°me pro p≈ôehlednost.
    IF sy-subrc = 0.
      SELECT *
        FROM zpp_api_matrix_l
        INTO TABLE mt_data_popup
        WHERE sap_id = lr_data->sap_id
        AND   werks  = lr_data->werks
        AND   charg  = lr_data->charg
        AND   api_id = lr_data->api_id.
    ENDIF.

    " Kontrola, zda jsou mt_Data_popup pr√°zdn√©.
    IF mt_data_popup IS NOT INITIAL.
      display_popup( ).
    ENDIF.

  ENDMETHOD.

  METHOD handle_user_command.

    DATA: row    TYPE lvc_t_row,
          lt_row TYPE lvc_t_row.

    CONSTANTS lc_halb TYPE mtart VALUE 'HALB'.

    CASE e_ucomm.
      WHEN  'ADD_ROW'.
        add_row( ).   " p≈ôidej ≈ô√°dek
        alv_refresh( ).


      WHEN  'SAVE' .

        IF mt_error IS INITIAL.
          " Mus√≠m udƒõlat kontrolu, zda u≈æivatel opravil chyby.
          save_row( ).   "
          alv_edit( ).
          alv_refresh( ).
        ELSE.
          " Mus√≠m zjisit, zda u≈æivatel odstranit errory.
          LOOP AT mt_error REFERENCE INTO DATA(lr_error).

            IF lr_error->fieldname = 'SAP_ID'.

              DATA(lr_data) = REF #( mt_data[ lr_error->row_id ] OPTIONAL ).

              SELECT SINGLE matnr
                 FROM mara
                INTO @DATA(lv_mara)
                WHERE matnr = @lr_data->sap_id.

              IF sy-subrc = 0.
                CLEAR lr_error->fieldname.
              ENDIF.

            ELSEIF lr_error->fieldname = 'WERKS'.

              lr_data = REF #( mt_data[ lr_error->row_id ] OPTIONAL ).
              " Zkontrolujeme, zda z√°vod existuje v tabulce T001W
              SELECT SINGLE werks
                FROM t001w
                INTO @DATA(lv_dummy)
              WHERE werks = @lr_data->werks.

              IF sy-subrc = 0.
                CLEAR lr_error->fieldname.
              ENDIF.

            ELSEIF lr_error->fieldname = 'CHARG'.
              DATA(lv_length) = 10.


              lr_data = REF #( mt_data[ lr_error->row_id ] OPTIONAL ).

              IF strlen( lr_data->charg ) = lv_length.
                IF sy-subrc = 0.
                  CLEAR lr_error->fieldname.
                ENDIF.
              ENDIF.

              " Zde vlo≈æ akci pro CHARG
            ELSEIF lr_error->fieldname = 'API_ID'.

              lr_data = REF #( mt_data[ lr_error->row_id ] OPTIONAL ).

              SELECT SINGLE matnr
                FROM mara
                INTO @lv_mara
                WHERE matnr = @lr_data->api_id.

              IF sy-subrc = 0.

                " Pokud je z√°znam v MATNR, ale nen√≠ HALB(VPOL u z√°kazn√≠ka)
                SELECT SINGLE matnr
                  FROM mara
                  INTO @lv_mara
                  WHERE matnr = @lr_data->api_id
                  AND   mtart = @lc_halb.

                IF sy-subrc = 0.
                  CLEAR lr_error->fieldname.
                ENDIF.
              ENDIF.

              "Datuv nen√≠ pot≈ôeba, zajim√° mƒõ jen platnost podle fin√°ln√≠ platnosti
            ELSEIF lr_error->fieldname = 'DATUB'.

              lr_data = REF #( mt_data[ lr_error->row_id ] OPTIONAL ).

              IF lr_data->datuv IS NOT INITIAL AND lr_data->datub IS NOT INITIAL AND lr_data->datuv <= lr_data->datub.
                CLEAR lr_error->fieldname.

              ENDIF.
            ENDIF.
          ENDLOOP.

          DELETE mt_error WHERE fieldname IS INITIAL.

          IF mt_error[] IS INITIAL.
            save_row( ).   "
            alv_edit( ).
            alv_refresh( ).
          ENDIF.
        ENDIF.

      WHEN 'DELETE'.
        delete( ).   " vyma≈æ
        alv_refresh( ).

      WHEN 'HISTORY'.
        read_popup( ).
        IF mt_data_popup IS NOT INITIAL.
          display_popup( ).
        ENDIF.
        alv_refresh_popup( ).
    ENDCASE.

  ENDMETHOD.

ENDCLASS.                  "lcl_app IMPLEMENTATION

DATA go_inst TYPE REF TO lcl_app.

MODULE status_0100 OUTPUT.

  SET PF-STATUS 'STATUS_0100'.

  IF r_all = 'X'.
    SET TITLEBAR '0100' .
  ELSEIF r_val = 'X'.
    SET TITLEBAR '0101' .
  ELSE.
    SET TITLEBAR '0102' .
  ENDIF.

  go_inst->alv_create( ).

ENDMODULE.                 " STATUS_0100  OUTPUT

MODULE user_command_0100 INPUT.

  DATA: lv_answer TYPE char1.

  CASE sy-ucomm.
    WHEN 'BACK' OR 'CANC' OR 'EXIT'.
*      IF lv_valid IS NOT INITIAL.
      IF gv_changed IS INITIAL.
        LEAVE TO SCREEN 0.
      ELSE.
        CALL FUNCTION 'POPUP_TO_CONFIRM'
          EXPORTING
            titlebar       = 'Ulo≈æen√≠ z√°znamu'
            text_question  = 'Chcete opustit neulo≈æen√° data?'
          IMPORTING
            answer         = lv_answer
          EXCEPTIONS
            text_not_found = 1
            OTHERS         = 2.
        IF sy-subrc = 0 AND lv_answer = '1'.
          LEAVE TO SCREEN 0.
        ENDIF.
      ENDIF.
  ENDCASE.
ENDMODULE.                 " USER_COMMAND_0100  INPUT

MODULE status_0200 OUTPUT.

  SET PF-STATUS 'STATUS_0200'.

  IF r_all = 'X'.
    SET TITLEBAR '0200' .
  ELSEIF r_val = 'X'.
    SET TITLEBAR '0201' .
  ELSE.
    SET TITLEBAR '0202' .
  ENDIF.

  go_inst->alv_create_popup( ).

ENDMODULE.                 " STATUS_0100  OUTPUT

MODULE user_command_0200 INPUT.
  CASE sy-ucomm.
    WHEN 'BACK' OR 'CANC' OR 'EXIT'.

      LEAVE TO SCREEN 0.

  ENDCASE.
ENDMODULE.                 " USER_COMMAND_0100  INPUT


INITIALIZATION.

  CLEAR gs_variant.
  gs_variant-report = sy-repid.

  CALL FUNCTION 'REUSE_ALV_VARIANT_DEFAULT_GET'
    EXPORTING
      i_save     = 'A'
    CHANGING
      cs_variant = gs_variant
    EXCEPTIONS
      not_found  = 2.

  IF sy-subrc = 0.
    p_varnt = gs_variant-variant.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_varnt.

  DATA  lv_exit TYPE c.

  CALL FUNCTION 'REUSE_ALV_VARIANT_F4'
    EXPORTING
      is_variant = gs_variant
      i_save     = 'A'
    IMPORTING
      e_exit     = lv_exit
      es_variant = gs_variant
    EXCEPTIONS
      not_found  = 2.

  IF sy-subrc = 2.
    MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF lv_exit EQ space.
      p_varnt = gs_variant-variant.
    ENDIF.
  ENDIF.

START-OF-SELECTION.

  CALL FUNCTION 'ENQUEUE_E_TABLE'
    EXPORTING
      tabname        = 'ZPP_API_MATRIX'
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.

  IF sy-subrc <> 0.
    CALL FUNCTION 'DEQUEUE_ALL'.
    MESSAGE e307(cz) WITH sy-msgv1 'ZPP_API_MATRIX'.
  ELSE.
* üöÄ
    CREATE OBJECT go_inst.
    go_inst->run( ).

    CALL FUNCTION 'DEQUEUE_E_TABLE'
      EXPORTING
        tabname = 'ZPP_API_MATRIX'.
  ENDIF.

* üöÄ
*  CREATE OBJECT go_inst.
*  go_inst->run( ).